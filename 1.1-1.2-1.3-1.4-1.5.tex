% A LaTeX template for MSc Thesis submissions to 
% Politecnico di Milano (PoliMi) - School of Industrial and Information Engineering
%
% S. Bonetti, A. Gruttadauria, G. Mescolini, A. Zingaro
% e-mail: template-tesi-ingind@polimi.it
%
% Last Revision: October 2021
%
% Copyright 2021 Politecnico di Milano, Italy. NC-BY

\documentclass{Configuration_Files/PoliMi3i_thesis}

%------------------------------------------------------------------------------
%	REQUIRED PACKAGES AND  CONFIGURATIONS
%------------------------------------------------------------------------------

% CONFIGURATIONS
\usepackage{parskip} % For paragraph layout
\usepackage{setspace} % For using single or double spacing
\usepackage{emptypage} % To insert empty pages
\usepackage{multicol} % To write in multiple columns (executive summary)
\setlength\columnsep{15pt} % Column separation in executive summary
\setlength\parindent{0pt} % Indentation
\raggedbottom  

% PACKAGES FOR TITLES
\usepackage{titlesec}
% \titlespacing{\section}{left spacing}{before spacing}{after spacing}
\titlespacing{\section}{0pt}{3.3ex}{2ex}
\titlespacing{\subsection}{0pt}{3.3ex}{1.65ex}
\titlespacing{\subsubsection}{0pt}{3.3ex}{1ex}
\usepackage{color}

% PACKAGES FOR LANGUAGE AND FONT
\usepackage[english]{babel} % The document is in English  
\usepackage[utf8]{inputenc} % UTF8 encoding
\usepackage[T1]{fontenc} % Font encoding
\usepackage[10pt]{moresize} % Big fonts

% PACKAGES FOR IMAGES
\usepackage{graphicx}
\usepackage{transparent} % Enables transparent images
\usepackage{eso-pic} % For the background picture on the title page
\usepackage{subfig} % Numbered and caption subfigures using \subfloat.
\usepackage{tikz} % A package for high-quality hand-made figures.
\usetikzlibrary{}
\graphicspath{{./Images/}} % Directory of the images
\usepackage{caption} % Coloured captions
\usepackage{xcolor} % Coloured captions
\usepackage{amsthm,thmtools,xcolor} % Coloured "Theorem"
\usepackage{float}
\usepackage{tkz-euclide}

% STANDARD MATH PACKAGES
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{bm}
\usepackage[overload]{empheq} % For braced-style systems of equations.
\usepackage{fix-cm} % To override original LaTeX restrictions on sizes

% PACKAGES FOR TABLES
\usepackage{tabularx}
\usepackage{longtable} % Tables that can span several pages
\usepackage{colortbl}

% PACKAGES FOR ALGORITHMS (PSEUDO-CODE)
\usepackage{algorithm}
\usepackage{algorithmic}

% PACKAGES FOR REFERENCES & BIBLIOGRAPHY
\usepackage[colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=black,menucolor=black,runcolor=black,urlcolor=black]{hyperref} % Adds clickable links at references
\usepackage{cleveref}
\usepackage[square, numbers, sort&compress]{natbib} % Square brackets, citing references with numbers, citations sorted by appearance in the text and compressed
\bibliographystyle{abbrvnat} % You may use a different style adapted to your field

% OTHER PACKAGES
\usepackage{pdfpages} % To include a pdf file
\usepackage{afterpage}
\usepackage{lipsum} % DUMMY PACKAGE
\usepackage{fancyhdr} % For the headers
\fancyhf{}

% Input of configuration file. Do not change config.tex file unless you really know what you are doing. 
\input{Configuration_Files/config}

%----------------------------------------------------------------------------
%	NEW COMMANDS DEFINED
%----------------------------------------------------------------------------

% EXAMPLES OF NEW COMMANDS
\newcommand{\bea}{\begin{eqnarray}} % Shortcut for equation arrays
\newcommand{\eea}{\end{eqnarray}}
\newcommand{\e}[1]{\times 10^{#1}}  % Powers of 10 notation

%----------------------------------------------------------------------------
%	ADD YOUR PACKAGES (be careful of package interaction)
%----------------------------------------------------------------------------
\usepackage{pgfplots}
\usepackage{mathrsfs}
\usepackage{cancel}

%----------------------------------------------------------------------------
%	ADD YOUR DEFINITIONS AND COMMANDS (be careful of existing commands)
%----------------------------------------------------------------------------
\newtheorem{definition}{Definition}[chapter]
%\newtheorem{proposition}{Definition}[section]
\DeclareMathOperator*{\subsetminus}{\mathrel{\dot{\subset}}}
%----------------------------------------------------------------------------
%	BEGIN OF YOUR DOCUMENT
%----------------------------------------------------------------------------

\begin{document}

\fancypagestyle{plain}{%
\fancyhf{} % Clear all header and footer fields
\fancyhead[RO,RE]{\thepage} %RO=right odd, RE=right even
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}}

%----------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------

\pagestyle{empty} % No page numbers
\frontmatter % Use roman page numbering style (i, ii, iii, iv...) for the preamble pages

\puttitle{
	title=QUANTUM COMPUTATION ON THE TORIC CODE, % Title of the thesis
	name=Alessia Conca Roncari, % Author Name and Surname
	course=Computer Science and Engineering - Ingegneria Informatica, % Study Programme (in Italian)
	ID  = 996809,  % Student ID number (numero di matricola)
	advisor= Prof. Michele Correggi, % Supervisor name
	coadvisor={Massimo Moscolari}, % Co-Supervisor name, remove this line if there is none
	academicyear={2023-24},  % Academic Year
} % These info will be put into your Title page 

%----------------------------------------------------------------------------
%	PREAMBLE PAGES: ABSTRACT (inglese e italiano), EXECUTIVE SUMMARY
%----------------------------------------------------------------------------
\startpreamble
\setcounter{page}{1} % Set page counter to 1

% ABSTRACT IN ENGLISH
\chapter*{Abstract} 
Here goes the Abstract in English of your thesis followed by a list of keywords.
The Abstract is a concise summary of the content of the thesis (single page of text)
and a guide to the most important contributions included in your thesis.
The Abstract is the very last thing you write.
It should be a self-contained text and should be clear to someone who hasn't (yet) read the whole manuscript.
The Abstract should contain the answers to the main scientific questions that have been addressed in your thesis.
It needs to summarize the adopted motivations and the adopted methodological approach as well as the findings of your work and their relevance and impact.
The Abstract is the part appearing in the record of your thesis inside POLITesi,
the Digital Archive of PhD and Master Theses (Laurea Magistrale) of Politecnico di Milano.
The Abstract will be followed by a list of four to six keywords.
Keywords are a tool to help indexers and search engines to find relevant documents.
To be relevant and effective, keywords must be chosen carefully.
They should represent the content of your work and be specific to your field or sub-field.
Keywords may be a single word or two to four words. 
\\
\\
\textbf{Keywords:} here, the keywords, of your thesis % Keywords

% ABSTRACT IN ITALIAN
\chapter*{Abstract in lingua italiana}
Qui va l'Abstract in lingua italiana della tesi seguito dalla lista di parole chiave.
\\
\\
\textbf{Parole chiave:} qui, vanno, le parole chiave, della tesi % Keywords (italian)

%----------------------------------------------------------------------------
%	LIST OF CONTENTS/FIGURES/TABLES/SYMBOLS
%----------------------------------------------------------------------------

% TABLE OF CONTENTS
\thispagestyle{empty}
\tableofcontents % Table of contents 
\thispagestyle{empty}
\cleardoublepage

%-------------------------------------------------------------------------
%	THESIS MAIN TEXT
%-------------------------------------------------------------------------
% In the main text of your thesis you can write the chapters in two different ways:
%
%(1) As presented in this template you can write:
%    \chapter{Title of the chapter}
%    *body of the chapter*
%
%(2) You can write your chapter in a separated .tex file and then include it in the main file with the following command:
%    \chapter{Title of the chapter}
%    \input{chapter_file.tex}
%
% Especially for long thesis, we recommend you the second option.

\addtocontents{toc}{\vspace{2em}} % Add a gap in the Contents, for aesthetics
\mainmatter % Begin numeric (1,2,3...) page numbering

% --------------------------------------------------------------------------
% NUMBERED CHAPTERS % Regular chapters following
% --------------------------------------------------------------------------
\chapter*{Introduction}

This document is intended to be both an example of the Polimi \LaTeX{} template for Master Theses,
as well as a short introduction to its use. It is not intended to be a general introduction to \LaTeX{} itself,
and the reader is assumed to be familiar with the basics of creating and compiling \LaTeX{} documents. 
\\
The cover page of the thesis must contain all the relevant information:
title of the thesis, name of the Study Programme and School, name of the author,
student ID number, name of the supervisor, name(s) of the co-supervisor(s) (if any), academic year.
The above information are provided by filling all the entries in the command \verb|\puttitle{}|
in the title page section of this template.
\\
Be sure to select a title that is meaningful.
It should contain important keywords to be identified by indexer.
Keep the title as concise as possible and comprehensible even to people who are not experts in your field.
The title has to be chosen at the end of your work so that it accurately captures the main subject of the manuscript. 
\\
Since a thesis might be a substantial document, it is convenient to break it into chapters.
You can create a new chapter as done in this template by simply using the following command
\begin{verbatim}
\chapter{Title of the chapter}
\end{verbatim}
followed by the body text.
\\
Especially for long manuscripts, it is recommended to give each chapter its own file.
In this case, you write your chapter in a separated \verb|chapter_n.tex| file
and then include it in the main file with the following command
\begin{verbatim}
\input{chapter_n.tex}
\end{verbatim}
It is recommended to give a label to each chapter by using the command
\begin{verbatim}
\label{ch:chapter_name}%
\end{verbatim}
where the argument is just a text string that you'll use to reference that part
as follows: \textit{Chapter~\ref{ch:chapter_one} contains \sc{an introduction to}  \dots}.\\
If necessary, an unnumbered chapter can be created by
\begin{verbatim}
\chapter*{Title of the unnumbered chapter}
\end{verbatim}






























\chapter{Toric code}
\label{ch:chapter_one}%
% The \label{...}% enables to remove the small indentation that is generated, always leave the % symbol.


\section{Spin Observables in Quantum Mechanics}
\label{sec:Observables}

In the context of quantum mechanics, an observable is a quantity that can be observed in a quantum system. Some examples could be: the position, momentum or energy of a system. The latter is represented by the Hamiltonian, which not only describes the energy but also encodes the rules that govern the dynamic of the system. 
Formally, an observable is over an Hilbert space $\mathscr{H}$ is represented by an Hermitian operator over $\mathscr{H}$.

\begin{definition} (Hilbert space)
	An Hilbert space $\mathscr{H}$ over $\mathbb{C}$ is a vector space on $\mathbb{C}$ over which is defined the scalar product $\langle \cdot \vert \cdot \rangle $: $\mathbb{C} \times \mathbb{C} \rightarrow \mathbb{C}$ .
\end{definition}

In particular, a 'spin' observable is a physical quantity associated with the intrinsic angular momentum of elementary particles, such as electrons. The spin is a fundamental property of particles and is characterized by a quantum number typically denoted as $S$, representing the spin quantum number.
In quantum mechanics, spin observables represent the possible measurements that can be made on the spin of a particle. Moreover, the spin is described using spin operators, which are, as anticipated above, hermitian matrices representing the components of the angular momentum of the spin along different directions. 



\subsection{Hermiticity and unitarity}

The hermiticity of an operator can be stated as follows:

\begin{definition} (Hermitian operator) Let $\mathscr{H}$ be an Hilbert space and  $A$: $\mathscr{H} \rightarrow \mathscr{H}$ be a linear operator. An operator $A$ is called Hermitian if for all $\psi,\phi \in \mathscr{H}$ we have that
\end{definition}

\begin{center}
	$\langle A\psi|\phi \rangle = \langle \psi|A^{\dagger}\phi \rangle = \langle \phi|A\psi \rangle^{*}$.
\end{center}

The daga symbol $\dagger$ represents the conjugate transpose and the $\langle \ \rangle$ the Hermitian inner product. A square matrix $A$ of complex numbers, representing a linear operator, is called hermitian if $A^{\dagger} = (A^*)^T = A$. There are two important consequences of hermiticity: firstly, it ensures that the operator possesses orthogonal eigenvectors; secondly, it ensures that the corresponding eigenvalues of the operator are real. 
Notice also that, for real matrices, it is sufficient to compute only the transpose of the matrix to verify hermiticity. \newline
%Furthermore, as mentioned above, vertex and plaquette operators satisfy the involutory property, which is derived from the unitarity of the matrices representing the vertex and plaquette operators, i.e. $X$ and $Z$ Pauli matrices. \newline 

In order to understand the dynamics of observables in time we introduce anotehr important property: unitarity. 
As previously said, observables such as position, momentum and energy are represented by hermitian operators, which ensure the existence of real eigenvalues and orthogonal eigenvectors. Though, unitarity governs the evolution in time of quantum states and operators. In particular, it ensures that the total probability of all possible outcomes of a measurement remains conserved over time, preserving the fundamental principles of quantum mechanics. 

\begin{definition} (Unitary operator) Let $\mathscr{H}$ be an Hilbert space and let $U$: $\mathscr{H} \rightarrow U$ be a linear operator. We define $U$ to be complex unitary if for all $\psi,\phi \in \mathscr{H}$ we have that
\end{definition}

\begin{center}
	$\langle U\psi|U\phi \rangle = \langle \psi|\phi \rangle$.
\end{center}

In terms of the conjugate transpose, we can define a complex matrix $U$ to be unitary if $ (U^*)^T=U^{-1}$. We can also define that a real matrix $U$, representing a linear operator, is unitary if $(U)^T = U^{-1}$ or, equivalently, if $(U)^T U=I$. 
%In our case this directly translates to $U^2=1$ beacause for $X$ and $Z$ Pauli matrices we have that $U^T=U$. Note also that one important property of  unitary operators is that their eigenvalues have modulus equal to one.\newline

Overall, hermiticity and unitarity provide a comprehensive framework for understanding the behavior of observables in quantum mechanics.


\subsection{The spectrum}

In the framework of quantum mechanics, the concept of the spectrum emerges as a natural consequence of the unitarity and hermiticity of observables. The spectrum of an observable refers to the set of possible values that can be obtained when measuring the physical quantity represented by the observable. 


%The trivial spectrum of vertices and plaquette operators will be of fundamental importance to perform fault-tolerant quantum compuations, in particular for measuring whether any error has occurred during computation (see Chapter 3). 


\subsection{Commutation and anticommutation}

Given two observables $A$ and $B$ we define the commutator as follows

\begin{center}
	$[A, B] = AB - BA$.
\end{center}

The two observables commute if 

\begin{center}
	$AB = BA$.
\end{center}

On the otehr hand, they anticommute if 

\begin{center}
	$AB = - BA$. 
\end{center}


\subsection{Spin-$\frac{1}{2}$ particles example}

In order to exemplify the above properties of observables, we take spin-$\frac{1}{2}$ particles \textit{as discussed in \cite{Cor23}}, i.e. electrons, and define the components of the spin in three dimensions. In this case the Hilbert space is bidimensional and the observables can be written in terms of Pauli matrices in the basis $\{ | \frac{1}{2}, \pm \frac{1}{2} \rangle \}$ (spin-up and spin-down):


\[
\begin{array}{ccc}
	\text{$S_3$} = \hbar
	\begin{pmatrix}
		1 & 0 \\
		0 & -1
	\end{pmatrix} &
	\text{$S_1$} = \hbar
	\begin{pmatrix}
		0 & 1 \\
		1 & 0
	\end{pmatrix} &
	\text{$S_2$} = \hbar
	\begin{pmatrix}
		0 & -i \\
		i & 0
	\end{pmatrix}
\end{array}
\]

Pauli matrices satisfy hermiticity and unitarity Moreover they satisfy some specific commuation and anticommutation properties.

Commutation properties:

\begin{center}
	$[\sigma_i, \sigma_j] = \sigma_i \sigma_j - \sigma_j \sigma_i 
	= 2i\epsilon_{ijk} \sigma_k$.
\end{center}

Where:

\begin{itemize}
	\item \( \epsilon_{ijk} \) is the Levi-Civita symbol.
\end{itemize}

Anticommutation properties:

\begin{center}
	$\{\sigma_i, \sigma_j\} = \sigma_i \sigma_j + \sigma_j \sigma_i 
	= 2 \delta_{ij}\mathbb{I}$.
\end{center}

Where:

\begin{itemize}
	\item \( \delta_{ij} \) is the Kronecker delta.
	\item \( \mathbb{I} \) is the identity matrix.
\end{itemize}


\subsection{Tensor product of Hilbert spaces}

Given two observables $A$ and $B$ that belong to a bidimensional Hilbert space we compute their tensor product $A \otimes B$ over $\mathbb{C}^2 \otimes \mathbb{C}^2$ given their respective basis.


\[
\begin{array}{ccc}
	\begin{pmatrix}
		u_1  \\
		u_2  
	\end{pmatrix} 
	\otimes
	\begin{pmatrix}
		w_1  \\
		w_2 
	\end{pmatrix} &
\end{array}
\]

Overall, we would obtain four combinations:

\[
\begin{array}{ccc}
	\begin{pmatrix}
		1 \\
		0  
	\end{pmatrix} 
	\otimes
	\begin{pmatrix}
		1  \\
		0 
	\end{pmatrix} ,
	
	\begin{pmatrix}
		1 \\
		0  
	\end{pmatrix} 
	\otimes
	\begin{pmatrix}
		0  \\
		1 
	\end{pmatrix} ,
	
	\begin{pmatrix}
		0 \\
		1  
	\end{pmatrix} 
	\otimes
	\begin{pmatrix}
		0  \\
		1 
	\end{pmatrix} ,
	
	\begin{pmatrix}
		0 \\
		1  
	\end{pmatrix} 
	\otimes
	\begin{pmatrix}
		1  \\
		0 
	\end{pmatrix} &
\end{array}
\]


Though, considering that $A$ acts only an the first Hilbert space $A \otimes \mathbb{I}$ and that $B$ acts only on the second $\mathbb{I} \otimes B$, we can rename:

\begin{center}
	$A \otimes \mathbb{I}$=$A_1$ \\
	$\mathbb{I} \otimes B$=$B_2$
\end{center}

and write the tensor product as a simple profuct of $A_1$ and $B_2$:

\begin{center}
	$A \otimes B$=$A_1$$B_2$.
\end{center}

This is because the operators acts locally, so we can ignore the identity. \newline
Similarly if we compute the tensor product explicitly, it becomes a simple product of the scalar products between the components of the basis:

\begin{center}
	$(u_1 \otimes w_1) \dot (u_2 \otimes w_2) = \langle u_1 | w_1 \rangle \langle u_2 | w_2 \rangle$
\end{center}







%------------------------------------

\newpage
\section{Description of the model}
\label{sec:Model}

The toric code model is defined on a square lattice with periodic boundary conditions in both directions. These latter characteristics are typical of what is known as a torus topology or simply a torus, after which the model takes name.\newline
A square lattice, here labelled as $\mathcal{L}$, is a particular lattice defined in a two dimensional space. It is denoted as $\mathbb{Z}^{2}$ such that each lattice point is identified with a tuple of integers. Though, the above mentioned boundary conditions also specify that for any site $(i, j)$ in the lattice, the neighboring sites are going to be: $((i+1) \ mod \ N, j)$, $((i-1) \ mod \ N, j)$, $(i, (j+1) \ mod \ N)$ and $(i, (j-1) \ mod \ N)$, where $N$ is the dimension of the torus.  \newline
Then, we are also going to consider a dual lattice, which will be labelled as $\mathcal{L}'$, and that will be positioned as represented in figure 1.1, where the continuous line represents the main lattice $\mathcal{L}$, while the dashed line represents its dual $\mathcal{L'}$.  	\newline

On each edge is located a spin-$\frac{1}{2}$ particle, i.e. a Fermion, represented in the image below with an empty circle. Circles shaded in gray represent the boundary conditions. 
For each cell on $\mathcal{L}$ we are going to consider two spins, therefore the total number of spins will correspond to $2N^2$, where $N$ represents both the total number of cells in $\mathcal{L}$ and the dimension of the lattice. 
Since all of these spins exhibit the same characteristics they are identified with identical particles, which will be useful to know in the next sections in order to study the behaviour of the system.

%\afterpage{
\begin{figure}[b]
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
		\end{tikzpicture}
	\end{center}
	
	\caption{Square lattice with boundary conditions.}
	\label{fig:lattice}
\end{figure}
%}

\newpage
The key part of the Toric Code are the so called \textit{vertex} and \textit{plaquette} operators that are going to be placed, respectively, on the vertices $v$ and cells $p$ of $\mathcal{L}$. Such operators can be defined formally as in definition 1.1 and implemented by means of Pauli matrices as exemplified in figure 1.2. 


\begin{figure}
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {-1,...,-1} %column
			{
				
				\draw[blue!50, line width=1.5mm] (\i,0.5) -- (\i,1.5);
				\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,0.5) {};
				\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,1.5) {};
				
			}
			\foreach \j in {1,...,1}
			{
				
				\draw[blue!50, line width=1.5mm] (-1.5, \j) -- (-0.5, \j);
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z},,label=\textbf{Av}] at (-1.5,\j) {};
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z}] at (-0.5,\j) {};
				
			}
			
			
			\foreach \i in {2,...,2}
			{
				
				\draw[red!80, line width=1.5mm] (\i,-1) -- (\i,0);
				\node[draw, circle, fill=red!80,label=center:\textbf{X}] at (\i,-0.5) {};
				
			}
			\foreach \j in {-1,...,-1}
			{
				
				\draw[red!80, line width=1.5mm] (2, \j) -- (1, \j);
				\draw node[draw,circle,fill=red!80,label=center:\textbf{X}] at (1.5,\j) {};
				
			}
			\foreach \i in {1,...,1}
			{
				
				\draw[red!80, line width=1.5mm] (\i,-1) -- (\i,0);
				\node[draw, circle, fill=red!80,label=center:\textbf{X},label=left:\textbf{Bp}] at (\i,-0.5) {};
				
			}
			\foreach \j in {0,...,0}
			{
				
				\draw[red!80, line width=1.5mm] (2, \j) -- (1, \j);
				\draw node[draw,circle,fill=red!80,label=center:\textbf{X}] at (1.5,\j) {};
				
			}
			
		\end{tikzpicture}
	\end{center}
	\caption{Veretx (blue) and plaquette (red) operators located, respectively, on a vertex $v$ and cell $p$.}
	\label{fig:operators}
\end{figure}



\begin{definition} (Vertex and Plaquette operators) Given a vertex $v$ and a plaquette $p$ we can define, respectively, vertex and plaquette operators as tensor products over Pauli operators, each acting locally on four neighbouring spins. 
	
\begin{center}
	
	$ A_v \coloneq Z_{l} \otimes Z_{r} \otimes Z_{u} \otimes Z_{b}$ 
	
	$ B_p \coloneq X_{l} \otimes X_{r} \otimes X_{u} \otimes X_{b}$  

\end{center}
\end{definition}

If we define each $Z_i$ and $X_i$ to be equal to the following tensor proucts:

\begin{center}
	
	$Z_i = \mathbb{I}_{\mathcal{L} \setminus  e_i} \otimes \sigma^z_{e_i}$ 
	
	$X_i = \mathbb{I}_{\mathcal{L} \setminus  e_i} \otimes \sigma^x_{e_i} $  
	
\end{center}


then, for the sake of simplicity, we can omit the tensor product because there is no risk of ambiguity in the interpretation. In fact, since the vertex and plaquette operators act locally, we can omit writing down the tensor product with the identity for sites that are not part of the support of the operator. Thus, we can simply rewrite them by means of the product of the Pauli matrices that act on the quartets of spins indexed as $j \in star(v)$ and $j \in bdy(p)$. 
 
\begin{center}
	$ A_v = \prod_{j \in star(v)} Z_j $ 
	
	$ B_p = \prod_{j \in bdy(v)} X_j $
\end{center}


All the elements that constitute the model of the toric code are brought together by its Hamiltonian. Definition 1.2 describes the Hamiltonian of the toric code 
\textit{according to \cite{Her20}}.

\begin{definition} (Toric Code Hamiltonian) Given vertex and plaquette operators each acting, respectively, on verteces and cells of the torus, we can define the following Hamiltonian for the system:
\end{definition}

\begin{center}
	
	$H = -\sum_{v} 
	A_v - \sum_{p} B_p $
	
\end{center}

Each one of the $A_v$ and $B_p$ operators that appear in the Hamiltonian share some important properties. Firstly, notice that $A_v$ and $B_p$ operators are Hermitian and square to the identity. Given the considerations made in definition 1.2 and 1.3 for real matrices, we can easily prove the first following proposition:

\begin{proposition} (Hermiticity and involutory property of $Av$ and $Bp$ operators)
$Av$ and $Bp$ operators are Hermitian and satisfy the involutory property.
\end{proposition}
	
\textit{Proof.}
We know that the operator $ A_v = \prod_{j \in star(v)} Z_j $ and that $ B_p = \prod_{j \in bdy(v)} X_j $ .\newline
Firstly, recall the form of the $\sigma_x$ and $\sigma_z$ matrices representing the Pauli gates $X$ and $Z$:



\[
\text{Z = $\sigma_z$} =
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix}
\]


\[
\text{X = $\sigma_x$} =
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix}
\]


It can be proved that they are Hermitian:\newline

\[
\text{$( \sigma_z )^{\dagger}$} = 
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix} ^\dagger =
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix}^T =
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix}
= \text{$ \sigma_z $}
\]


\[
\text{$( \sigma_x )^{\dagger}$} = 
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix} ^\dagger =
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix}^T =
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix}
= \text{$ \sigma_x $}
\]\newline

since Pauli matrices are real matrices and thus $A^{\dagger}=A^T$.
%Then, knowing that $[\sigma_i,\sigma_j]=0 \ for \ i=j$ we can write:

\begin{center}
	$(A_v)^{\dagger} = (\sigma_{x_1} \sigma_{x_2} \sigma_{x_3} \sigma_{x_4})^{\dagger} = \sigma_{x_1}^{\dagger} \sigma_{x_2}^{\dagger} \sigma_{x_3}^{\dagger} \sigma_{x_4}^{\dagger} = \sigma_{x_1} \sigma_{x_2} \sigma_{x_3} \sigma_{x_4} = Av$ \newline
	
	$(B_p)^{\dagger} = (\sigma_{z_1} \sigma_{z_2} \sigma_{z_3} \sigma_{z_4})^{\dagger} = \sigma_{z_1}^{\dagger} \sigma_{z_2}^{\dagger} \sigma_{z_3}^{\dagger} \sigma_{z_4}^{\dagger} = \sigma_{z_1} \sigma_{z_2} \sigma_{z_3} \sigma_{z_4} = Bp$ \newline
\end{center}

It can also be proved that they satisfy the involutory property:\newline

\[
\text{$( \sigma_z )^{2}$} = 
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix} *
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix} =
\begin{pmatrix}
	1 & 0 \\
	0 & 1
\end{pmatrix}
= \text{$I$}
\]


\[
\text{$( \sigma_x )^{2}$} = 
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix} *
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix} =
\begin{pmatrix}
	1 & 0 \\
	0 & 1
\end{pmatrix}
= \text{$I$}
\]\newline


Then, again we can write \newline

\begin{center}
	$(A_v)^{2} = (\sigma_{x_1} \sigma_{x_2} \sigma_{x_3} \sigma_{x_4})^{2} = \sigma_{x_1}^2 \sigma_{x_2}^2 \sigma_{x_3}^2 \sigma_{x_4}^2 = I$ 
	
	$(B_p)^{2} = (\sigma_{z_1} \sigma_{z_2} \sigma_{z_3} \sigma_{z_4})^{2} = \sigma_{z_1}^2 \sigma_{z_2}^2 \sigma_{z_3}^2 \sigma_{z_4}^2 = I$
\end{center}

\hfill $\square$

Given proposition 1.1, we can know further characterize the opeartors in terms of their eigenvalues and define their spectrum.

\begin{proposition} (Eigenvalues of $A_v$ and $B_p$ operators) Given Hermitian operators $A_v$ and $B_p$, which satisfy the involutory property, their possible eigenvalues are $\pm 1$.
\end{proposition}


\textit{Proof.}\newline
Given the Hermiticity and involutory proof in 1.1, we firstly prove that vertex and plaquette operators have real eigenvalues: 

write the expression for the eigenvalues $A_v |\xi \rangle = \lambda |\xi \rangle$ and take as hypothesis that $|\xi \rangle \neq 0$. Then, by means of the scalar product:

\begin{center}
	$\langle \xi|A_v|\xi \rangle = \lambda \langle \xi | \xi \rangle$
	
	$\lambda = \frac {\langle \xi|A_v|\xi \rangle}{\langle \xi |\xi \rangle}$ = $\frac {\langle \xi|A_v|\xi \rangle}{||\xi||^2}$ = $\frac {\langle \xi|A_v^{\dagger}|\xi \rangle}{||\xi||^2}$ = $\frac {\langle \xi|A_v|\xi\rangle^*}{||\xi||^2}$ = $\lambda^*$ 
\end{center}

Notice that we have applied antilinearity of the adjoint in the penultimate equality: 

\begin{center}
	$(\langle \xi|A_v^{\dagger}|\xi \rangle)^{\dagger}$ = $|\xi\rangle^{\dagger} (A_v^{\dagger})^{\dagger} \langle\xi|^{\dagger}$ = $\langle \xi|A_v|\xi \rangle^*$.  
\end{center}

Therefore, we have derived that the eigenvalues of $A_v$ are $\lambda = \lambda^*$, which implies that they must be real.

%Using hermiticity with the fact that $(Av)^2=I$ we can derive the unitarity of $Av$ and state that $Av Av^{\dagger} = Av^{\dagger} Av = (Av)^2 = I$. \newline
%Given the property of unitarity, which states that the corresponding eigenvalues of the operator have modulus equal to one,:\newline 

Then we exploit unitarity while taking as hypothesis that $|\xi \rangle \neq 0$. 
We write the expression $A_v |\xi \rangle = \lambda |\xi \rangle$ and its self-adjoint $\langle \xi| A_v^{\dagger} = \lambda^* \langle \xi|$. Recall that $A_v^{\dagger}=A_v^{-1}$, thus by means of the scalar product we obtain 

\begin{center}
	$\langle \xi|A_v A_v^{\dagger}|\xi\rangle = \lambda \lambda^* \langle \xi |\xi \rangle$
	
	$\langle \xi|I|\xi \rangle = \lambda \lambda^* \langle \xi |\xi \rangle$
	
	$\langle \xi|\xi \rangle = \lambda \lambda^* \langle \xi |\xi \rangle $
	
	$ \lambda \lambda^* = 1 $
	
	$ |\lambda|^2 = 1 $
\end{center}

Which means that the eigenvalues of $A_v$ have modulus equal to one, as expected. Though, this can happen for two real choices of $\lambda$ which are $+1$ and $-1$.
Therefore, putting together hermiticity and unitarity, 

\begin{center}
$\begin{cases}
	 \lambda = \lambda^* \\
	 |\lambda|^2 = 1 
\end{cases}$
\end{center}

we obtain that the only two remaining possibilities for the eigenvalues of $A_v$ are $\pm 1$. \newline

The same reasoning can be carried out for the plaquette operators.

\hfill $\square$ 

Given the result of proposition 1.2, is easy to find the spectrum of the operators: 

\begin{proposition} (Spectrum of $A_v$ and $B_p$ operators) The spectrum of $A_v$ and $B_p$ operators is equal to $\{-1,+1\}$. 
\end{proposition}

In particular, if we compute the corresponding eigenvalue of $A_v$ (or $B_p$), this can either assume value $-1$ or $+1$ according to the fact that the Pauli matrices that make up the operator anticommute, respectively, with an odd or even number of edges.
In fact we can prove that following relationships between vertex and plaquette operators holds:

\begin{proposition} (Commutation of $A_v$ and $B_p$ operators) The operator $A_v$ commutes with the operator $B_p$ for an even number of edges.
\end{proposition}


\begin{proposition} (Anticommutation of $A_v$ and $B_p$ operators) The operator $A_v$ anticommutes with the operator $_Bp$ for an odd number of edges.
\end{proposition}


\textit{Proof.}\newline 
%Av commutes with itself.\newline
%Bp commutes with itself.\newline
%Av commutes with Bp for an even number of edges.\newline
Fix the origin of the coordinate system in the bottom left corner of the lattice as shown in figure 1.3. 

\begin{figure}
\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-3,-2.5,...,3}
		{
			\draw[dashed] (\i,-3) -- (\i,3);
		}
		\foreach \j in {-3,-2.5,...,3}
		{
			\draw[dashed] (-3,\j) -- (3,\j);
		}
		
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-3,-3) grid (3,3);
		\foreach \i in {-2.5,...,2.5}
		{
			\foreach \j in {-2.5,...,2.5}
			{
				
				
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=2
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=2
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		\foreach \i in {-1,...,-1} %column
		{
			
			\draw[blue!50, line width=1.5mm] (\i,0.5) -- (\i,1.5);
			\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,0.5) {};
			\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,1.5) {};
			
		}
		\foreach \j in {1,...,1}
		{
			
			\draw[blue!50, line width=1.5mm] (-1.5, \j) -- (-0.5, \j);
			\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z},label=\textbf{Av}] at (-1.5,\j) {};
			\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z} ] at (-0.5,\j) {};
			
		}
		
		
		
		
		\foreach \i in {1.5,...,1.5}
		{
			
			\draw[red!70, line width=1.5mm] (\i,-1) -- (\i,0);
			\node[draw, circle, fill=red!70,label=center:\textbf{X},label=left:\textbf{Bp}] at (\i,0) {};
			\node[draw, circle,fill=red!70,label=center:\textbf{X}] at (\i,-1) {};
			
		}
		\foreach \j in {-0.5,...,-0.5}
		{
			
			\draw[red!70, line width=1.5mm] (2, \j) -- (1, \j);
			\draw node[draw,circle,fill=red!70,label=center:\textbf{X}] at (1,\j) {};
			\draw node[draw,circle,fill=red!70,label=center:\textbf{X} ] at (2,\j) {};
			
		}
		
		% Define vertices
		\coordinate (A) at (-3,-3);
		\coordinate (B) at (-1,1);
		
		% Draw vector
		\draw[->, line width=1.1pt] (A) -- (B) node[right] {$\vec{v}$};
		
		
		% Define vertices
		\coordinate (A) at (-3,-3);
		\coordinate (B) at (1.5,-0.5);
		
		% Draw vector
		\draw[->, line width=1.1pt] (A) -- (B) node[right] {$\vec{p}$};
		
		
		
		
		
		
		% Define vertices
		\coordinate (A) at (-3,-3);
		\coordinate (B) at (-3,-2);
		
		% Draw vector
		\draw[->, line width=1.1pt] (A) -- (B) node[midway, left] {$\vec{e2}$};
		
		
		% Define vertices
		\coordinate (A) at (-3,-3);
		\coordinate (B) at (-2,-3);
		
		% Draw vector
		\draw[->, line width=1.1pt] (A) -- (B)  node[midway, below] {$\vec{e1}$};
		
		
		
	\end{tikzpicture}
\end{center}

\caption{Vertex and plaquette operators according to the coordinate system with origin in (0,0). Here the plaquette operator is implemented on $\mathcal{L}'$ in order to coherently define its edges from the point of view of $\mathcal{L}$ using vector $\vec{v}$.}
\label{fig:coordinate_system}
\end{figure}


Then, we can define the two vectors representing the site of application of the vertex and plaquette operator, respectively over the lattice $\mathcal{L}$ and dual lattice $\mathcal{L}'$ \newline

\begin{center}
	$\vec{v}$= $n\hat{e_1} + m\hat{e_2}$, where $n,m \in \mathbb{Z}$ 
	
	$\vec{p}$= $(n + \frac{1}{2}) \hat{e_1} + (m + \frac{1}{2}) \hat{e_2}$, where $n,m \in \mathbb{Z}$.
\end{center}

Rewrite the operators as follows: \newline

\begin{center}
	
	$A_{\vec{v}} = \sigma^z_{\vec{v}+\frac{1}{2}\hat{e_1}} \sigma^z_{\vec{v}+\frac{1}{2}\hat{e_2}} \sigma^z_{\vec{v}-\frac{1}{2}\hat{e_1}} \sigma^z_{\vec{v}-\frac{1}{2}\hat{e_2}}$ 
	
	$B_{\vec{p}} = \sigma^x_{\vec{p}+\frac{1}{2}\hat{e_1}} \sigma^x_{\vec{p}+\frac{1}{2}\hat{e_2}} \sigma^x_{\vec{p}-\frac{1}{2}\hat{e_1}} \sigma^x_{\vec{p}-\frac{1}{2}\hat{e_2}}$.
	
\end{center}

In order to simplify the calculations we rewrite $Bp$ on the lattice $\mathcal{L}$ by rewriting the indeces in terms of vector $\vec{v}$ \newline

\begin{center}
	$(n\hat{e_1} + m\hat{e_2}) + \frac{1}{2}\hat{e_2}= n\hat{e_1} + (m+\frac{1}{2}\hat{e_2})$
	
	$(n\hat{e_1} + m\hat{e_2}) + \frac{1}{2}\hat{e_1}= (n+ \frac{1}{2})\hat{e_1} + m\hat{e_2}$
	
	$(n\hat{e_1} + m\hat{e_2}) + \frac{1}{2}\hat{e_1}+\hat{e_2}= (n+ \frac{1}{2})\hat{e_1} + (m + 1)\hat{e_2}$
	
	$(n\hat{e_1} + m\hat{e_2}) + \frac{1}{2}\hat{e_2}+\hat{e_1}= (n+ 1)\hat{e_1} + (m + \frac{1}{2})\hat{e_2}$.
\end{center}


Then the $B_{\vec{p}}$ operator becomes: \newline

\begin{center}
	
	$B_{\vec{v}} = \sigma^x_{n\hat{e_1} + (m+\frac{1}{2}\hat{e_2})} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + (m + 1)\hat{e_2}} \sigma^x_{(n+ 1)\hat{e_1} + (m + \frac{1}{2})\hat{e_2}}$ \newline
	
\end{center}

and the Hamiltonian can be written by grouping the indices: \newline

\begin{center}
	
	$H = - \sum_{m,n \in \mathbb{Z}} \{ 
	\sigma^z_{(n+\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m+\frac{1}{2})\hat{e_2}} \sigma^z_{(n-\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m-\frac{1}{2})\hat{e_2}} +
	\sigma^x_{n\hat{e_1} + (m+\frac{1}{2}\hat{e_2})} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + (m + 1)\hat{e_2}} \sigma^x_{(n+ 1)\hat{e_1} + (m + \frac{1}{2})\hat{e_2}} \} $.\newline
	
\end{center}

Now calcuate the commutator $[A_{\vec{v}},B_{\vec{v}}] = A_{\vec{v}}B_{\vec{v}} - B_{\vec{v}}A_{\vec{v}}$ by focusing on the first term: \newline

\begin{center}
	
	$ A_{\vec{v}}B_{\vec{v}} =
	\sigma^z_{(n+\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m+\frac{1}{2})\hat{e_2}} \sigma^z_{(n-\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m-\frac{1}{2})\hat{e_2}} $ *
	
	$\sigma^x_{n\hat{e_1} + (m+\frac{1}{2}\hat{e_2})} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + (m + 1)\hat{e_2}} \sigma^x_{(n+ 1)\hat{e_1} + (m + \frac{1}{2})\hat{e_2}}$. \newline
	
\end{center}


Matrices do not always commute but for Pauli matrices we have the following commutation relationship :
\newline

\begin{center}
	$\sigma^x_{\vec{v}}\sigma^z_{\vec{v}'} = \sigma^z_{\vec{v}'} \sigma^x_{\vec{v}} + 2 * \sigma^x_{\vec{v}}\sigma^z_{\vec{v}'} \delta_{\vec{v} \vec{v}'}$\newline
\end{center}

where $\hspace{1cm} \delta_{\vec{v} \vec{v}'} =$
$\begin{cases}
	1, \hspace{1cm} if \hspace{1cm}  \vec{v} = \vec{v}'\\
	0, \hspace{1cm} if \hspace{1cm} \vec{v} \neq \vec{v}'
\end{cases}$\newline

which states that 	$\sigma^x_{\vec{v}}\sigma^z_{\vec{v}'}$ commutate for $\vec{v} \neq \vec{v}'$   but anticommutate for $\vec{v} = \vec{v}'$. This is known from the anticommutation relationship of Pauli matrices $\sigma^x \sigma^z = - \sigma^x \sigma^z$. Thus, for an even numer of overlapping edges, in our case 2 or 4, the commutator becomes:\newline

\begin{center}
	
	$[A_{\vec{v}},B_{\vec{v}}] = 2 *
	\sigma^x_{n\hat{e_1} + (m+\frac{1}{2}\hat{e_2})} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + (m + 1)\hat{e_2}} \sigma^x_{(n+ 1)\hat{e_1} + (m + \frac{1}{2})\hat{e_2}}*
	\sigma^z_{(n+\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m+\frac{1}{2})\hat{e_2}} \sigma^z_{(n-\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m-\frac{1}{2})\hat{e_2}} $. \newline

\end{center}
Instead, for an odd number of edges it becomes null: $[A_{\vec{v}},B_{\vec{v}}]=0$.

This calculations conclude that $A_{\vec{v}},B_{\vec{p}}$ commute for an even numer of edges but anticommute for an odd number of edges.\newline

\hfill $\square$\newline

Now that we have described the toric code model and its operators, we proceed to compute its ground state, which is at the heart of its fault-tolerant behaviour. The ground state arises from the interaction of vertex and plaquette operators acting on the system's lattice. Through the characterization of these operators and the understanding of their role in enforcing some additional constraints, we gain insight into the structure of the ground state manifold. \newline
In the following section, we derive the unique features of the ground state, including its topological order. \newline 

%--------------



















\newpage
\section{Ground states}
\label{sec:GS}

The ground state of the toric code, represents the system's lowest energy configuration. What makes this ground state particularly intriguing is its highly degenerate nature, meaning that there are numerous distinct configurations that all share the same minimum energy. 
The ground state exhibit topological order, characterized by non-local correlations between spins. This means that the model is robust  even when the system undergoes local perturbations.  In fact, quantum entanglement between spins is not confined to neighboring pairs, instead, it extends over long distances and involves collective behaviours of spins that cannot be understood by considering them individually.
Not only, as we will see, these features are intimately related to the underlying topology of the torus. This topological protection ensures the robustness of quantum information against local perturbations, giving the toric code the potential to be feasibly applied in quantum information processing (see Chapter 3).\newline

We start by explicitly defining the ground state by making use of the properties of the vertex and plaquette operators that we have derived in the previous section.

\begin{proposition} (Ground state of the toric code Hamiltonian) The ground states of the toric code Hamiltonian are the simultaneous $+1$ eigenstates of all the $Av$ and $Bp$ operators. 
\end{proposition}

\textit{Proof.}\newline 
Recall the form of the Hamiltonianin, having N lattice sites, in the following way 

\begin{center}
	
	$H = -\sum_{i=1}^{N}
	Av_i - \sum_{j=1}^{N} Bp_j $
	
\end{center}

we already know that Hermitian matrices are simultaneously diagonalizable, moreover $Av$ and $Bp$ operators commute for an even number of edges, thus there exists a common base of eigenvectors with their respective eigenvalues. We also know from proposition 1.2 that such eigenvalues can assume two values $\{-1,+1\}$ due to the specific properties of our operators.

To determine the ground state of the Hamiltonian we have to determine the minimum energy of the system. Therefore we compute all the possible combinations of the eigenvalues associated to the vertex and palquette operators to obtain the following range of values:

\begin{center}
	$\sigma( H) =$
	$\begin{cases}
		2N, \hspace{1cm} if \ all\ Av,Bp \ have \ \lambda_{H}= -1\\
		2N-1,\\
		.\\
		intermediate \ energies,\\
		.\\
		-2N+1\\
		-2N, \hspace{1cm} if \ all \ Av,Bp \ have \ \lambda_{H}= +1
	\end{cases}$
	
\end{center}

Taking the minimum of this spectrum means considering $\sigma(H)=-2N$, thus considering only eigenstates for the Hamiltonian associated to $+1$ eigenvalues.
Those are the ones that will form a basis for the ground state manifold of the system.\newline

\hfill $\square$


In order to determine which are the admissible configurations of eigenstates that we can use to form the ground state, we treat the $Av$ and $Bp$ operators as constraint equations over the torus, i.e. the lattice and dual lattice.
As a consequence, all of our configurations will need to respect the two following equations:

\begin{center}
	(1)	$Av|\psi\rangle$ = $+1|\psi\rangle$
\end{center}

\begin{center}
	(2)	$Bp|\psi\rangle$ = $+1|\psi\rangle$
\end{center}

This means that configuration $|\psi\rangle$ needs to be be an eigenvector for both $Av$ and $Bp$ operators. \newline
In order to satisfy equation (1), we look for loop configurations such that if we apply $Av$ to that state, the result would still yield an overall positive value.\newline
Graphically, we identify the loop configurations through strings of 'occupied' edges (shaded in black in figure 1.4 and 1.5), each identified as a qubit in configuration $|1\rangle$. Then, if we apply $Av$ at one of the open ends of such strings, we have two possibilities: leaving the string of occupied edges open (figure 1.4) or closing the string over the $Av$ operator (figure 1.5).
In the first case, what we do is computing $\sigma^{z} |1\rangle$ for one endpoint of the string, which implies obtaining $-1|1\rangle$ eigenvalue for that endpoint; as a result we violate contraint (1). In the second case, instead, we end up with positive eigenvalues for each edge, this is becuse the negative signs obtained at the endpoints cancel themselves out. Overall, in order to respect contraint (1) we are interested only in closed loops on $Av$. Notice that such loops will always have an even length and will always involve a maximum of two extremities of the $Av$ operator.\textit{\cite{Her20}}

%drawings closed/open loop with Av
\begin{figure}
	
	\begin{center}
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {-2,...,-2}
			{
				\draw[black, line width=1.5mm] (\i,-0.5) -- (\i,1.5);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};
				
				\draw[blue!50, line width=1.5mm] (\i,1.5) -- (\i,2.5);
				\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,1.5) {};
				\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,2.5) {};
				
				
			}
			
			\foreach \j in {2,...,2}
			{
				
				\draw[blue!50, line width=1.5mm] (-2.5, \j) -- (-1.5, \j);
				
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z},label=north:\textbf{Av}] at (-2.5,\j) {};
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z}] at (-1.5,\j) {};
				
			}
			
			
		\end{tikzpicture}
	\end{center}
	
	\caption{Operator $Av$ applied on an open string of occupied edges.}
	\label{fig:Aveigen2}
\end{figure}




\begin{figure}
	
\begin{center}
\begin{tikzpicture}
	% Draw dashed lines
	\foreach \i in {-3,-2.5,...,3}
	{
		\draw[dashed] (\i,-3) -- (\i,3);
	}
	\foreach \j in {-3,-2.5,...,3}
	{
		\draw[dashed] (-3,\j) -- (3,\j);
	}
	
	
	
	% Draw solid grid and nodes with circles in the middle of each side
	\draw[step=1cm] (-3,-3) grid (3,3);
	\foreach \i in {-2.5,...,2.5}
	{
		\foreach \j in {-2.5,...,2.5}
		{
			
			
			\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
				\node[right,xshift=0.2cm,yshift=0.4cm] {};
				% Convert \j and \i to integers
				\pgfmathtruncatemacro{\intj}{\j}
				\pgfmathtruncatemacro{\inti}{\i}
				
				% Draw circles at the midpoints of each side
				\ifnum\intj=2
				\draw node[draw,circle,fill=gray] at (0,0.5) {};
				\else
				\draw node[draw,circle,fill=white] at (0,0.5) {};
				\fi
				
				\ifnum\inti=2
				\draw node[draw,circle,fill=gray] at (0.5,0) {};
				\else
				\draw node[draw,circle,fill=white] at (0.5,0) {};
				\fi
				
				\draw node[draw,circle,fill=white] at (0,-0.5) {};
				\draw node[draw,circle,fill=white] at (-0.5,0) {};
			\end{scope}
		}
	}
	
	\foreach \i in {-2,...,-2}
	{
		\draw[black, line width=1.5mm] (\i,-1) -- (\i,1.5);
		\node[draw, circle, fill=black] at (\i,-0.5) {};
		\node[draw, circle, fill=black] at (\i,0.5) {};
		
		\draw[blue!50, line width=1.5mm] (\i,1.5) -- (\i,2.5);
		\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,1.5) {};
		\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,2.5) {};
		
		
	}
	
	\foreach \j in {2,...,2}
	{
		
		\draw[blue!50, line width=1.5mm] (-2.5, \j) -- (-1.5, \j);
		
		
		\draw[black, line width=1.5mm] (-1.5, \j) -- (1, \j);
		\draw node[draw,circle,fill=black] at (-0.5,\j) {};
		\draw node[draw,circle,fill=black] at (0.5,\j) {};
		\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z},label=north:\textbf{Av}] at (-2.5,\j) {};
		\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z}] at (-1.5,\j) {};
		
	}
	
	
	\foreach \i in {1,...,1}
	{
		\draw[black, line width=1.5mm] (\i,-1) -- (\i,2);
		\node[draw, circle, fill=black] at (\i,-0.5) {};
		\node[draw, circle, fill=black] at (\i,0.5) {};
		\draw node[draw,circle,fill=black] at (\i,1.5) {};
		
	}
	
	\foreach \j in {-1,...,-1}
	{
		\draw[black, line width=1.5mm] (-2, \j) -- (1, \j);
		\draw node[draw,circle,fill=black] at (0.5,\j) {};
		\draw node[draw,circle,fill=black] at (-0.5,\j) {};
		\draw node[draw,circle,fill=black] at (-1.5,\j) {};
	}
	
	
\end{tikzpicture}
\end{center}

\caption{String of occupied edges closed on an operator $Av$.}
\label{fig:Aveigen}
\end{figure}
		
In a more formal notation what we are stating is that:

\begin{center}
	$\prod_{i=1}^{4} \sigma_{i}^{z} |\psi\rangle = +1 |\psi\rangle$. 
\end{center}

If we consider only closed loops, we can identify different configurations having such characteristic. The illustrations in figure 1.6 show some examples of them.
Each of these loops, having such characteristics, is an eigenstate for $Av$ since, no matter how I locally apply $Av$, I will always preserve the sign of the state. 

%drawings 4 types of loops


\begin{figure}
	
	\begin{center}
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {-1,...,-1}
			{
				\draw[black, line width=1.5mm] (\i,-1) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};	
				
			}
			
			\foreach \i in {1,...,1}
			{
				\draw[black, line width=1.5mm] (\i,-1) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};	
				
			}
			
			\foreach \j in {1,...,1}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (1,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, fill=black] at (0.5,\j) {};		
				
			}
			
			\foreach \j in {-1,...,-1}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (1,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, fill=black] at (0.5,\j) {};		
				
			}
			
			
		\end{tikzpicture}
		
	\end{center}
	
	\vspace{1cm} 
	
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};		
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			
		\end{tikzpicture}		
	\end{center}
	
	\vspace{1cm} 
	
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[black, line width=1.5mm] (-2,\j) -- (2,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, fill=black] at (0.5,\j) {};		
				\node[draw, circle, fill=black] at (-1.5,\j) {};
				\node[draw, circle, fill=black] at (1.5,\j) {};		
				
			}
			
			
		\end{tikzpicture}
	\end{center}
	
	\vspace{1cm} 
	
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};		
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[black, line width=1.5mm] (-2,\j) -- (2,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, fill=black] at (0.5,\j) {};		
				\node[draw, circle, fill=black] at (-1.5,\j) {};
				\node[draw, circle, fill=black] at (1.5,\j) {};		
				
			}
			
			
		\end{tikzpicture}		
	\end{center}
	
	\caption{Examples of closed loops yielding $+1$ eigenvalue for $Av$}
	\label{fig:Loops}
\end{figure}


Now we focus on constraint (2). We want to apply the plaquette operator $Bp$ only to eigenstates of $Av$, which we have determined above. The illustration in figure 1.7 shows an example of how to do it in practice with one of the eigenstates of $Av$.
Notice that, after the transformation, we do always end up in a valid eigenstate of $Av$ but the new state $|\psi'\rangle$ is not an eigenstate of $Bp$ by itself.

%drawings Bp applied to loops
\begin{figure}
	
	\begin{center}
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[red!80, line width=1.5mm] (\i,0) -- (\i,1);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (\i,0.5) {};
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[red!80, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (\i,0.5) {};
				
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[red!80, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (-0.5,\j) {};		
				
			}
			
			\foreach \j in {1,...,1}
			{
				\draw[red!80, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (-0.5,\j) {};	
				
			}
			
			
		\end{tikzpicture}
		
		
		
		\vspace{1cm} 
		
		
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,0.5) {};
				
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};		
				
			}
			
			\foreach \j in {1,...,1}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, black] at (-0.5,\j) {};	
				
			}
			
			
		\end{tikzpicture}	

	\end{center}

\caption{Examples of $Bp$ to a closed loop.}
\label{fig:applyBp}
\end{figure}


Furthermore, any new configuration that we obtain through the application of the plaquette operator to an eigenstate of $Av$ simply yields one of the possible permutations of the edges of the initial state, provided that the topological characteristics of the loop are preserved.

This means that if we firstly partition the eigenstates of $Av$ in the following fours classes: 

\begin{enumerate}
	\item class 0 : contains all closed loops and thus the null state,
	this is because all of the closed loops can be continuously deformed into a null state;
	
	\item class 1 : contains loops that wind all the way around the horizontal dimension of the torus and their permutations;
	
	\item class 2 : contains loops that wind all the way around the vertical dimension of the torus and their permutations;
	
	\item class 3 : contains loops that wind all the way around both dimension of the torus and their permutations. Notice that the vertical loop must be taken on the dual lattice to yield a valid configuration.
	
\end{enumerate}

Then, applying a plaquette operator to any of the eigenstates belonging to one of the classes above must yield an eigenstate that lies in the same class. This is formally expressed by stating that the class is invariant under the action of the operator $Bp$. 

\begin{proposition} (Invariance under $Bp$) The four classes of eigenstates of $Av$ are invariant under the action of the $Bp$ operator. 
\end{proposition}

We can prove that the above definition holds by means of counterexamples. \newline



%drawing loop chiuso ma unito da Bp
\begin{figure}
	
	\begin{center}	
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,1.5) {};
				
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};		
				
			}
			
			\foreach \j in {1,...,1}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, black] at (-0.5,\j) {};	
				
			}
			
			
		\end{tikzpicture}	
		
		\vspace{1cm} 
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
				\draw[red!80, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=red!80, label = center:\textbf{X}] at (\i,0.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
				
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\draw[red!80, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,1.5) {};
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (\i,0.5) {};
				
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[red!80, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (-0.5,\j) {};		
				
			}
			
			\foreach \j in {1,...,1}
			{
				\draw[red!80, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (-0.5,\j) {};
				
				
			}
			
			
		\end{tikzpicture}	
		
		\vspace{1cm} 
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
				\draw[black, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,0.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
				
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\draw[black, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,1.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};
				
			}
			
			
			
		\end{tikzpicture}	
		

	\end{center}

\caption{Apply $Bp$ to a closed loop.}
\label{fig:Bpstrano}
\end{figure}

If we take the loop illustrated in figure 1.8 and close it by means of a plaquette operator as illustrated, we would be brought to believe that there indeed exist a way to apply the operator $Bp$ such that we exit class zero and land in class 1. Though, this is not possible. \newline
In fact, we can show the impossibility of the above action by defining two topological indeces to label the four categories of eigenstates. These indeces can assume values in $\mathbb{Z}_2=\{\overline{0},\overline{1} \}$, whose elements respectively represent the 'sets' of even and odd numbers. In our context such numerosities identify the number of vertical and horizontal loops of a configuration intersecting the vertical and horizontal dimensions of the torus (figure 1.9).

The above indeces can be expressed more clearly as follows: 

\begin{center}
	$n_x= (number \ of \ vertical \ intersections)mod2 = 
	\begin{cases} 
		0mod2 \\
		1mod2  
	\end{cases}$ 
\end{center}
\begin{center}
	$n_y= (number \ of \ horizontal \ intersections)mod2 =\begin{cases} 
		0mod2 \\
		1mod2  
	\end{cases}$ 
\end{center}


in order to create a correspondence with the actual definition of the torus over $(\mathbb{Z}$ x $\mathbb{Z})$. 
%We only change the representatives of the elements $\{\overline{0},\overline{1} \}$ in the intermediate step. \newline

In total our classes are going to be wider than expected; we can label them as : $(\overline{0},\overline{0} )$, $(\overline{0},\overline{1} )$, $(\overline{1},\overline{0})$, $(\overline{1},\overline{1})$.\newline

For example, if we take again the configuration in figure 1.9, we have 1 vertical intersection and 1 horizontal intersection, therefore we are in the class three indexed by $n_x=1mod2$ and $n_y=1mod2$, which is labelled as $(\overline{1},\overline{1})$. This would have been true for any odd number of vertical and horizintal intersections, since they all fall in the set of numbers given by $1mod2$.


%drawing 1 vertical 1 hor
\begin{figure}
	\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-2,-1.5,...,2}
		{
			\draw[dashed] (\i,-2) -- (\i,2);
		}
		\foreach \j in {-2,-1.5,...,2}
		{
			\draw[dashed] (-2,\j) -- (2,\j);
		}
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-2,-2) grid (2,2);
		\foreach \i in {-1.5,...,1.5}
		{
			\foreach \j in {-1.5,...,1.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=1
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=1
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		\foreach \i in {0,...,0}
		{
			\draw[black, line width=1.5mm] (\i,-2) -- (\i,2);
			\node[draw, circle, fill=black] at (\i,-0.5) {};
			\node[draw, circle, fill=black] at (\i,0.5) {};		
			\node[draw, circle, fill=black] at (\i,-1.5) {};
			\node[draw, circle, fill=black] at (\i,1.5) {};		
			
		}
		
		\foreach \j in {0,...,0}
		{
			\draw[black, line width=1.5mm] (-2,\j) -- (2,\j);
			\node[draw, circle, fill=black] at (-0.5,\j) {};
			\node[draw, circle, fill=black] at (0.5,\j) {};		
			\node[draw, circle, fill=black] at (-1.5,\j) {};
			\node[draw, circle, fill=black] at (1.5,\j) {};		
			
		}
		
		
	\end{tikzpicture}		
\end{center}

\caption{Notice that the above mentioned intersections are meant to be computed by fixing two circles (figure 1.9): one horizontal circle and one vertical circle passing passing through the spins of the main lattice.}
\label{fig:thirdkind}
\end{figure}


Similarly, if we go back to the configuration in figure 1.8, this would mean that, after having applied $Bp$ we do not land in class 1, as thought, but in class 0; this is because we have an even number of horizontal intersections and an even number of vertical intersections, i.e.   $(\overline{0}, \overline{0})$.

What follows naturally is that all the classes are $Bp$-$invariant$ due to the topological characteristics of the torus. More formally we can write that, given a set of eigenstates of $Av$ named $|\psi_1\rangle,...,|\psi_i\rangle,...,|\psi_n\rangle$ all belonging to the same class and forming state $|\psi\rangle$. Given that we know that $Bp|\psi_i\rangle=+|\psi_j\rangle$, then if we apply $Bp$ to the normalized state $|\psi\rangle$ we get:

\begin{center}
	$|\Xi\rangle= Bp \frac{1}{\sqrt{n}} \sum_{j=1}^{n} |\psi_i\rangle = \frac{1}{\sqrt{n}} \sum_{j=1}^{n} Bp |\psi_i\rangle = \frac{1}{\sqrt{n}} \sum_{j=1}^{n} |\psi_J\rangle =|\Xi\rangle$
\end{center}

because, as anticipated in the previous pages, what $Bp$ does is only permuting the $|\psi_i\rangle$, thus we get back our initial state. This result leads to the following proposition:

\begin{proposition}(Eigenstates of $Bp$) Eigenstates of $Av$ are not eigenstates of $Bp$ by themselves but completely symmetric superspositions of any of them.
\end{proposition}

From Proposition 1.6 and Proposition 1.7, also naturally follows the degeneracy (and dimension) of the ground state: \newline

\begin{proposition} (Degeneracy of the ground state) The degeneracy of the ground state manifold is $4$. 
\end{proposition}

Because the four classes of eigenstates are $Bp$-$invariant$, we can construct a valid ground state through the configurations belonging to one the four classes, as these configurations respect both contraint (1) and (2).\newline 

Now that we have derived the ground state configurations of the toric code, we focus on studying its excited states. These states, arise from perturbations or interactions within the system and offer valuable insights into the dynamic behavior of the toric code beyond its ground state equilibrium. While the ground state embodies the system's lowest energy configuration and serves as the foundation of its stability, the excited states provide an insight into the system's response to external influences. 
Through the systematic study of these excitations we discover some intrinsic characteristics of the toric code that will serve us later to explain its fault-tolerant nature.


%-------------------------





















\newpage
\section{Excited states}
\label{sec:ES}

%We shall now examine the case of a square lattice with boundary conditions, i.e. the toric code. \newline

Taking into account the results yielded by the examination of the physical system in the previous chapters we will now proceed to describe, firstly, what are the excitations on the ground state and what kind of excitations we can obtain on the ground state; after this, we will examine the exchange statistics of the excitations.\newline
In general, the low-energy excitations of a quantum system, often referred to as quasiparticles, represent deviations from the system's ground state. These excitations are associated with elementary quantum particles that can be created or annihilated with relatively low energy. The properties of these quasiparticles, including their statistics, are crucial for gaining insights into the system's ground state degeneracy, topological properties, and response to external perturbations. \newline

In the particular case of the toric Code, such low-energy excitations can be created in two ways: 

\begin{enumerate}
	\item through the application of an open-ended string $S^x$ made up of $\sigma^x$ operators on the ground state;
	
	\item through the application of an open-ended string $S^z$ made up of $\sigma^z$ operators on the ground state.
\end{enumerate}

At the extremities of the above mentioned strings, particles are created. We will call the pairs of particles obtained through the application of operator $S^x$ \textit{electric charges}, while the ones obatained by applying an $S^z$ operator to the ground states \textit{magnetic vortices}.\newline

%picture
\begin{figure}[b]
	
	\begin{center}
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {-2,...,-2}
			{
				\draw[red!30, line width=1.5mm] (\i,-1) -- (\i,-0.5);
				\draw[red!50, line width=1.5mm] (\i,-0.5) -- (\i,1.5);
				\draw[red!30, line width=1.5mm] (\i,1.5) -- (\i,2);
				\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=south:\textbf{\large \bf $e$}] at (\i,-0.5) {};
				\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (\i,0.5) {};
				\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=north:\textbf{\bf \large $e$}] at (\i,1.5) {};
				
			}
			
			\foreach \j in {-1.5,...,-1.5}
			{
				\draw[blue!30, line width=1.5mm] (0.5, \j) -- (1, \j);
				\draw[blue!50, line width=1.5mm] (1, \j) -- (2, \j);
				\draw[blue!30, line width=1.5mm] (2, \j) -- (2.5, \j);
				
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{$\sigma^z$},label=left:\textbf{\large \bf $m$}] at (1,\j) {};
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{$\sigma^z$},label=right:\textbf{\large \bf $m$}] at (2,\j) {};
				
			}
			
			
		\end{tikzpicture}
	\end{center}
	
	\caption{$e$ and $m$ excitations on the ground state.}
	\label{fig:excitations}
\end{figure}





\newpage
We can prove that if a string $S^x$ of $\sigma^x$ operators is open-ended, then the $\sigma^x$ operators at the two extremes of the string will anticommute with one $A_v$ each. 

\begin{proposition}(Anticommutation od $S^x$)
	The string $S^x$ operators anticommute with two $A_v$ each.
\end{proposition}

\textit{Proof.}\newline
We want to show that $A_v S^x + S^x A_v=0$. Knowing that 

\begin{center}
	$A_v = \prod_{i=1}^{4} \sigma_i^z$ \\ 
	$S^x = \prod_{j=1}^{N} \sigma_j^x$
\end{center}

by substitution we obtain the following expression: 

\begin{center}
	$\prod_{i=1}^{4} \prod_{j=1}^{N} \sigma_j^x + \prod_{j=1}^{N} \sigma_j^x \prod_{i=1}^{4} \sigma_i^z = 0$ $(1)$
\end{center}

remeber that only one $\sigma_i^z$ will overlap with the extremity of the string $S^x$; thus, only one $\sigma_i^z$ will anticommute with the extremity of the string $S^x$. Knowing that for Pauli matrices acting on the same edge we have anticommutation

\begin{center}
	$\sigma_{v'}^x \sigma_{v'}^z = - \sigma_{v'}^z \sigma_v^x$ for $v=v'$ \\
	$\sigma_v^x \sigma_{v'}^z =  \sigma_{v'}^z \sigma_v^x$ for $v \neq v'$ 
\end{center}

if for simplicity we fix $N=2$ we can easily see that :

\begin{center}
	$(\sigma_1^z \sigma_2^z \sigma_3^z \sigma_4^z)(\sigma_1^x \sigma_2^x)  = - (\sigma_1^x \sigma_2^x)(\sigma_1^z \sigma_2^z \sigma_3^z \sigma_4^z) $ 
\end{center}

having supposed that, for example, the extremity $\sigma_1^x$ overlaps with the $\sigma_3^z$ edge part of the $A_v$ operator. This can then be easily generalized for $N$ Pauli operators. Finally, if we substitute such expressione in $(1)$ we obtain that the overall equation is in fact equal to zero. \newline
This procedure should be iterated also for the other extremity of the string $S^x$ to show that the operator commutes with two $A_v$ operators, one for each endpoint.\newline

\hfill $\square$ 

In the same way, we could prove that, if we take a string $S^z$ made up of $\sigma_z$ operators still open-ended, the $\sigma^z$ operators at its endpoints will anticommute with one $B_p$ each.

\begin{proposition}(Anticommutation od $S^z$)
	The string $S^z$ operators anticommute with two $B_p$ each.
\end{proposition}

The effect of putting such strings on the ground states correspond to raising the associated energy of the GS by 2. In fact, coherently with what said in \textit{\cite{Her20}}, it is impossible to create unitary excitations on the ground states.

\begin{proposition}(Magnitude of the excitations)
	Placing string operators on the ground states correspond to raising the associated energy of the GS by 2.
\end{proposition}

\textit{Proof.} \newline
Recall that for a string operator, here we will choose $S^x$, both equations hold:

\begin{center}
	$\begin{cases} 
		A_{v1} S^x + S^x A_{v1} =0 \\
		A_{v2} S^x + S^x A_{v2} =0
	\end{cases}$ 
\end{center}

If we apply the string operator to the Ground State, taking into account anticommutativity stated above, we obtain that:

\begin{center}
	$\begin{cases}
		A_{v1} S^x |GS\rangle = - S^x A_{v1} |GS\rangle = - S^x |GS\rangle \\
		
		A_{v2} S^x |GS\rangle = - S^x A_{v2} |GS\rangle = - S^x |GS\rangle
	\end{cases}$ 
\end{center}

since $A_{v1}|GS\rangle = +1|GS\rangle$ and $A_{v2}|GS\rangle = +1|GS\rangle$.
Summing up term by term :

\begin{center}
	$\begin{cases}
		A_{v1} S^x |GS\rangle + A_{v2} S^x |GS\rangle = - 2 S^x A_{v1} |GS\rangle
	\end{cases}$ 
\end{center}

Thus, if the energy of the Ground State as we have defined it in the previous chapters is $-2N$ by acting with a string operator on  it we obtain a final energy equal to $-2N+2$.

\hfill $\square$ 

%Firstly, we study the individual statistics of electric charges and magnetic votices, then we argue their mutual statistics.\newline






\subsection{Fermionic and bosonic exchange statistics in 3D and 2D}
We shall give a brief description of the statistics of fermions and bosons in both cases of three and two dimensions.
Let us first consider the exchange statistics of two particles in three dimensions.  We can describe a system of two particles moving from point $(r_1(t_1),r_2(t_1))$ to point $(r'_1(t_2),r'_2(t_2))$ \textit{by means of the following path integral formulation given in \cite{Rao16}}:

\begin{center}
	$A$ = $\sum_{paths} e^{iS}$
\end{center}

\textit{where $S$ represents the integral of the lagrangian $\mathcal{L}$ over time}.
% which provides a measure of the total \textit{action} along a particular trajectory or path taken by the system. 

\begin{center}
	$S = \int_{t_1}^{t_2}dt \textit{$\mathcal{L}$} [ r_1(t),r_2(t) ] $.
\end{center}

In quantum mechanics, the path integral formulation involves considering all possible paths between the initial and final states and assigning a phase factor $e^{iS}$ to each.\newline
Then, the probability amplitude for a system to evolve from one point to another is given by the sum over all paths of these phase factors.\newline
Moreover, since we are talking about a system of indistinguishable particles, we will only have two classes of paths in three dimensions: the direct paths and paths with exchanges. This is because, the final configuration at time $t_2$ will always be the same due to indistinguishability. Though, notice that even though two paths may lead to the same final configuration they can exhibit different behaviors. To visualize this, consider the case where particles move in space but their paths do not intersect. In such a scenario, paths are constrained to move on a sphere. Therefore, closed paths on the sphere emerge when particles return to their original positions (no exchange) or reach the antipodal point (exchange). Overall we will have three distinct paths: 

%picture


\begin{enumerate}
	\item[Path a]: being a closed loop without exchange; it can disappear if reduced to a point, implying that the wave-function cannot acquire any phase; 
	
	\item[Path b] : involving a single exchange; it connects two fixed points on the sphere, making it impossible to erase it. Consequently, this exchange introduces a phase in the wave-function;
	
	\item[Path c] : forming a closed loop with two exchanges, as in case 1; as a result, also in this case the wavefunction does not acquire any additional phase.
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{"../Thesis/Immagine 2024-02-22 113658"}
	\caption{\textit{ Possible exchanges of two particles in 3D. From: \cite{Rao16}.}}
	\label{fig:immagine-2024-02-22-113658}
\end{figure}

Therefore, we only have two classes of paths: those that do not involve any exchange as in class a and c, and those that are characterised by an exchange as in class b.\newline
Let $\eta$ represent the phase acquired by the wave function under a single exchange, then since two exchanges are equivalent to no exchange $\eta^2=1$ and it follows that $\eta = \pm 1 $. We can conclude that the only possible statistics in three dimensions are indeed the fermionic and bosonic ones.\newline

In terms of the path integral formulation that we have provided above, what we will get is:

\begin{center}
	$A[r_1(t_1),r_2(t_1) \rightarrow r'_1(t_2),r'_2(t_2)]$ = $\sum_{direct \ paths} e^{iS}$ + $e^{i \phi} \sum_{exchange \ paths} e^{iS}$.
\end{center}

Since exchanging the particles twice leads again to a direct path, we will have $e^{2i \phi} = 1$. This means that $\phi$ can either be 0 or $\pi$ giving rise, respectively, to bosonic and fermionic statistics. 

\begin{enumerate}
	\item $\phi = 0$: This case leads to the constructive interference of the exchange paths. The resulting particles are known as bosons, and their behavior is characterized by this specific phase condition;
	
	\item $\phi = \pi$: This case results in destructive interference between the exchange paths. The particles corresponding to this scenario are referred to as fermions, and their behavior is governed by this particular phase condition.
\end{enumerate}

In the two dimensional case, the topology of the space configuartion changes. In fact, in this case we end up moving on a circle.\newline
Though, in this case several possible paths are possible, in particular closed paths.
If we look again at the three classes of paths we see that we know have:

\begin{enumerate}
	\item[Path a] : can be shrunk into a point as it simply moves on the circle;

	\item[Path b] : cannot be contracted into a point as the endpoints remain fixed;

	\item[Path c] : also this kind of paths cannot be shrunk into a point since they wind all  the way around the circle. In three dimensions, the path that forms under two exchanges can be erased, but this is not possible if the exchange happens in two dimensions.
\end{enumerate}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{"../Thesis/Immagine 2024-02-22 112906"}
	\caption{ \textit{ Possible exchanges of two particles in 2D. From: \cite{Rao16}.}}
	\label{fig:immagine-2024-02-22-112906}
\end{figure}

Bacause of the third class of paths, if we let $\eta$ represent the phase associated with a single exchange, $\eta^2$ will denote the phase under two exchanges and $\eta^3$ the phase under three exchanges and so forth. The crucial observation is that, given that the wavefunction's modulus remains constant during exchanges, we can express $\eta$ as a phase factor $e^{i\theta}$. \newline

Again, in terms of path integral formulation, what we get as probability amplitude is:

\begin{center}
	$A$ = $\sum_{direct \ paths} e^{iS}$ + $e^{i \phi} \sum_{ one \ exchange} e^{iS}$  + $e^{2i \phi} \sum_{ two \ exchanges} e^{iS}$  + ...
\end{center}

where for $ \phi = 0, \pi$ we would obtain the usual bosons and fermions statistics, but since in general, $e^{in\phi} \neq 1$ for any $n$ (n exchanges never yield the identity), $\phi$ can be anything so any statistic is possible in two dimensions.
Such diverse statistics in two dimensions are called \textit{anyonic} (see section 1.5).\newline

We should also mention that, in a formal mathematical context, the analysis presented in this section categorizes fermions and bosons within the realm of the permutation group $\mathbb{P}_N$. Conversely, the subsequent analysis of anyonic excitations classifies them according to the braid group $\mathbb{B}_N$. \newline

The permutation group $\mathbb{P}_N$ is defined as the set of all possible permutations involving $N$ objects. Within this group, the operation of group multiplication (exchange) corresponds to the sequential application of permutations, and the group inverse involves the reversal of the permutation.
Here, executing a permutation twice on two objects results in the restoration of the system to its initial configuration. Consequently, particles exhibiting transformations according with representations of the permutation group can exclusively fall into the categories of either bosons or fermions. \newline

On the other hand, when it comes to objects that are part of the braid group $\mathbb{B}_N$, we can visualise the process of moving (or exchanging) particles as paths in spacetime with time being the vertical axis and space being the horizontal axis. The particles can circle around each other and form closed paths by coming back to their original positions. \newline
In a formal sense, we define the braid group $\mathbb{B}_N$ as the collection of diverse trajectories that arise during the transport of $N$ particles. \newline
%----

We can now analyze the statistics of $e$-particles in the context of the ground state of the toric code, \textit{as exemplified in \cite{Rao16}}. If we take a simple string operator $\sigma^z|GS\rangle$ , where $|GS\rangle$ denotes the ground state, it creates two $e$-particles in the vertices adjacent to the edge, as shown in figure 1.13. We know that a string operator of the form $\prod_{j=1}^{N} \sigma_j^z$ allows the separation of these two excitations. In fact, as illustrated in figure 1.13, the exchange of these particles becomes possible by applying the string operator in such a way that it moves the excitations around the lattice until they reach configuration shown in figure 1.13(c). However, due to the commutation of all $\sigma^x$ with each other, after the application of a closed loop of $\sigma^x$ (last passage in figure 1.13), there is no overall acquired phase. Consequently, the $e$-excitations exhibit bosonic statistics. A similar argument can be carried out for the $m$-excitations, establishing them as bosons as well.


%picture
\begin{figure}
\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-2,-1.5,...,2}
		{
			\draw[dashed] (\i,-2) -- (\i,2);
		}
		\foreach \j in {-2,-1.5,...,2}
		{
			\draw[dashed] (-2,\j) -- (2,\j);
		}
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-2,-2) grid (2,2);
		\foreach \i in {-1.5,...,1.5}
		{
			\foreach \j in {-1.5,...,1.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=1
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=1
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		
		
		\foreach \j in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (-0.5, \j);
			%\draw node[label=north:\textbf{ \large $e_1$}] at (-1,\j) {};
			\draw[red!50, line width=1.5mm] (-0.5, \j) -- (0, \j);
			%\draw node[label=north:\textbf{ \large $e_2$}] at (0,\j) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=left:\textbf{ \large $e_1$},label=right:\textbf{ \large $e_2$}] at (-0.5,1) {};
			
		}
		
	\end{tikzpicture}
\end{center}

\vspace*{1cm}

\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-2,-1.5,...,2}
		{
			\draw[dashed] (\i,-2) -- (\i,2);
		}
		\foreach \j in {-2,-1.5,...,2}
		{
			\draw[dashed] (-2,\j) -- (2,\j);
		}
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-2,-2) grid (2,2);
		\foreach \i in {-1.5,...,1.5}
		{
			\foreach \j in {-1.5,...,1.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=1
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=1
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		
		
		\foreach \j in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (-0.5, \j);
			\draw node[label=center:\textbf{\large $e_2$}] at (0,\j) {};
			%\draw[red!50, line width=1.5mm] (-0.5, \j) -- (0, \j);
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,1) {};
			
		}
		
		\foreach \i in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,1) -- (\i,-1);
			%\draw node[label=north:\textbf{e1}] at (\i,0) {};
			%\draw[blue!50, line width=1.5mm] (\i,0) -- (\i,0);
			
			\node[draw, circle, fill=red!50,,label=center:\textbf{$\sigma^x$}] at (-1,0.5) {};
			\node[draw, circle, fill=red!50,,label=center:\textbf{$\sigma^x$}] at (-1,-0.5) {};
			
		}
		
		\foreach \j in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (1, \j);
			
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (0.5,-1) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (1,-0.5) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,-1) {};
			
		}
		
		\foreach \i in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,-0.4) -- (\i,0.4);
			\draw node[label=north:\textbf{\large $e_1$}] at (\i,0.5) {};
			%\draw[blue!50, line width=1.5mm] (\i,0) -- (\i,0);
			\draw[red!50, line width=1.5mm] (\i,-1) -- (\i,-0.6);
			
			\node[draw, circle, fill=red!50,,label=center:\textbf{$\sigma^x$}] at (1,0.5) {};
			
		}
		
		
		
	\end{tikzpicture}
\end{center}

\vspace*{1cm}

\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-2,-1.5,...,2}
		{
			\draw[dashed] (\i,-2) -- (\i,2);
		}
		\foreach \j in {-2,-1.5,...,2}
		{
			\draw[dashed] (-2,\j) -- (2,\j);
		}
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-2,-2) grid (2,2);
		\foreach \i in {-1.5,...,1.5}
		{
			\foreach \j in {-1.5,...,1.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=1
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=1
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		
		
		\foreach \j in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (0.5, \j) -- (1, \j);
			\draw node[label=center:\textbf{\large $e_1$}] at (0,\j) {};
			\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (0.5,\j) {};
			%\draw node[label=center:\textbf{e2}] at (0,\j) {};
			%\draw[red!50, line width=1.5mm] (-0.5, \j) -- (0, \j);
			
			%\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,1) {};
			
		}
		
		\foreach \i in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,-1) -- (\i,0.5);
			\draw node[label=center:\textbf{\large $e_2$}] at (\i,1) {};
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-1,0.5) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-1,-0.5) {};
			
		}
		
		\foreach \j in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (1, \j);
			
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (0.5,-1) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (1,-0.5) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,-1) {};
			
		}
		
		\foreach \i in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,-0.4) -- (\i,0.4);
			\draw[red!50, line width=1.5mm] (\i,-1) -- (\i,-0.6);
			\draw[red!50, line width=1.5mm] (\i,0.6) -- (\i,1);
			
			\node[draw, circle, fill=red!50,,label=center:\textbf{$\sigma^x$}] at (1,0.5) {};
			
		}
		
		
		
	\end{tikzpicture}
\end{center}

\vspace*{1cm}

\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-2,-1.5,...,2}
		{
			\draw[dashed] (\i,-2) -- (\i,2);
		}
		\foreach \j in {-2,-1.5,...,2}
		{
			\draw[dashed] (-2,\j) -- (2,\j);
		}
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-2,-2) grid (2,2);
		\foreach \i in {-1.5,...,1.5}
		{
			\foreach \j in {-1.5,...,1.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=1
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=1
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		
		
		\foreach \j in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (-0.5, \j);
			%\draw node[label=north:\textbf{ \large $e_1$}] at (-1,\j) {};
			\draw[red!50, line width=1.5mm] (-0.5, \j) -- (0, \j);
			%\draw node[label=north:\textbf{ \large $e_2$}] at (0,\j) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=left:\textbf{ \large $e_2$},label=right:\textbf{ \large $e_1$}] at (-0.5,1) {};
			
		}
		
	\end{tikzpicture}
\end{center}


\caption{In the first picture we show the creation of a pair of $e$-excitations on the ground state by means of $\sigma^x$ operator. In the following pictures we move around the excitations using a string operator until we reach the configuration in the third picture. In the last passage we apply a closed loop of $\sigma^x$ in order to go back to the first kind of configuartion. \textit{\cite{Rao16}} }
\label{fig:base}
\end{figure}

%--------------------------

























\newpage
\section{Anyonic excitations}
\label{sec:AE}

Let's examine the mutual statistics between $e$ and $m$ particles. Initially, we generate pairs of excitations at distinct chosen sites by applying the operator $\sigma^z\sigma^x|GS\rangle$ as shown in figure 1.14. Afterward, we separate the excitations using string operators and we move an $m$-particle around an $e$-particle, as depicted in figure 1.15. Notably, there is a site where $\sigma^z$ must pass beyond a $\sigma^x$ spin, resulting in an anticommutation and thus introducing a minus sign. 
The closed loop can be eliminated, leading to the following transformation:

\begin{center}
	$\sigma_i^z\sigma_j^x|GS\rangle = - \sigma_i^x\sigma^z|GS\rangle$
\end{center}

if we denote the exchange operator as $R$ then the wave function relation should be the following:

\begin{center}
	$R^2\psi(e,m) = - \psi(e,m)$
\end{center}

since we are going all the way around the particle, we assume to have two exchanges. Then we simply find out that:

\begin{center}
	$R^2 = - 1 \rightarrow ( e^{-\frac{i\pi}{2}})^2 = - 1  \rightarrow R = e^{-\frac{i\pi}{2}} = \pm i $
\end{center}

this results falls out of the usual bosonic/fermionic statistics, thus we can say that the low-energy excitations of the ground state exhibit anyonic statistics (\textit{any} statistics).\newline


%picture
\begin{figure}
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			
			
			
			\foreach \j in {1,...,1}
			{
				
				\draw[red!50, line width=1.5mm] (-2, \j) -- (1, \j);
				%\draw node[] at (0,\j) {};
				\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=right:\textbf{\large $e$}] at (0.5,\j) {};
				\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,\j) {};
				\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=left:\textbf{\large $e$}] at (-1.5,\j) {};
				
			}
			
			
			\foreach \j in {-0.5,...,-0.5}
			{
				
				\draw[blue!50, line width=1.5mm] (-2.5, \j) -- (0.5, \j);
				
				
				\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z$},label=left:\textbf{\large $m$}] at (-2,\j) {};
				\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z$},label=right:\textbf{\large $m$}] at (0,\j) {};
				\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z$}] at (-1,\j) {};
				
			}
			
			
		\end{tikzpicture}
	\end{center}
	
	
	\caption{Creation of the $e$-excitations and $m$-excitations.}
	\label{fig:anyons1}
\end{figure}

\begin{figure}
\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-3,-2.5,...,3}
		{
			\draw[dashed] (\i,-3) -- (\i,3);
		}
		\foreach \j in {-3,-2.5,...,3}
		{
			\draw[dashed] (-3,\j) -- (3,\j);
		}
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-3,-3) grid (3,3);
		\foreach \i in {-2.5,...,2.5}
		{
			\foreach \j in {-2.5,...,2.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=2
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=2
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		
		
		\foreach \j in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (-2, \j) -- (1, \j);
			%\draw node[] at (0,\j) {};
			\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (0.5,\j) {};
			\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,\j) {};
			\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=left:\textbf{\large $e$}] at (-1.5,\j) {};
			
		}
		
		\foreach \i in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,-1) -- (\i,1);
			\draw node[label=center:\textbf{\large $e$}] at (\i,1) {};
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-1,0.5) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-1,-0.5) {};
			
		}
		
		\foreach \j in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (1, \j);
			
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (0.5,-1) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (1,-0.5) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,-1) {};
			
		}
		
		\foreach \i in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,-0.4) -- (\i,0.4);
			\draw[red!50, line width=1.5mm] (\i,-1) -- (\i,-0.6);
			\draw[red!50, line width=1.5mm] (\i,0.6) -- (\i,1);
			
			\node[draw, circle, fill=red!50,,label=center:\textbf{$\sigma^x$}] at (1,0.5) {};
			
		}
		
		\foreach \j in {-0.5,...,-0.5}
		{
			
			\draw[blue!50, line width=1.5mm] (-2.5, \j) -- (0.5, \j);
			
			
			\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z$},label=left:\textbf{\large $m$}] at (-2,\j) {};
			\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z$},label=right:\textbf{\large $m$}] at (0,\j) {};
			\node[draw, circle, fill=purple!50,label=center:\textbf{$\pm$}] at (-1,\j) {};
			
		}
		
		
	\end{tikzpicture}
\end{center}


\caption{Creation of an anyonic excitation by braiding of $e$ and $m$ pairs of particles. Here we loop the $e$-excitation around an $m$-excitation. The red loop of $\sigma^x$ can be removed with the result that the GS acquires a phase of $-1$.}
\label{fig:anyons}
\end{figure}



%-------------------------------









\chapter{Coding on the toric code}
\label{ch:chapter_two}

\section{Classical error correction}
\label{sec:CER}



\section{Quantum error correction (QEC)}
\label{sec:QEC}



\section{QEC in the toric code}
\label{sec:TC}













\chapter{Conclusions and future developments}
\label{ch:conclusions}%
A final chapter containing the main conclusions of your research/study
and possible future developments of your work have to be inserted in this chapter.

%-------------------------------------------------------------------------
%	BIBLIOGRAPHY
%-------------------------------------------------------------------------

\addtocontents{toc}{\vspace{2em}} % Add a gap in the Contents, for aesthetics
%\bibliography{Thesis_bibliography} % The references information are stored in the file named "Thesis_bibliography.bib"
\begin{thebibliography}{99} % Replace '99' with the widest label in your bibliography
	\bibitem[Cor23]{Cor23} M. Correggi, \textit{Aspetti Matematici della Meccanica Quantistica}, 2023.
	\bibitem[Her20]{Her20} P. Herringer, "The Toric Code", {\it RP}, 2020.
	\bibitem[Kit02]{Kit02} A. Yu. Kitaev, "Fault-tolearnt quantum computation ny anyons", {\it Annals of Physics} {\bf 2003}, 2-30, 2002.
	\bibitem[Rao16]{Rao16} S. Rao, "Introduction to abelian and non-abelian anyons", {\it Harish-Chandra Research Institute}, 1-20, {2016}.
\end{thebibliography}


%-------------------------------------------------------------------------
%	APPENDICES
%-------------------------------------------------------------------------

\cleardoublepage
\addtocontents{toc}{\vspace{2em}} % Add a gap in the Contents, for aesthetics


% LIST OF FIGURES
\listoffigures



% ACKNOWLEDGEMENTS
\chapter*{Acknowledgements}
Here you might want to acknowledge someone.

\cleardoublepage

\end{document}
