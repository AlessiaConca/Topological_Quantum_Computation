% A LaTeX template for MSc Thesis submissions to 
% Politecnico di Milano (PoliMi) - School of Industrial and Information Engineering
%
% S. Bonetti, A. Gruttadauria, G. Mescolini, A. Zingaro
% e-mail: template-tesi-ingind@polimi.it
%
% Last Revision: October 2021
%
% Copyright 2021 Politecnico di Milano, Italy. NC-BY

\documentclass{Configuration_Files/PoliMi3i_thesis}

%------------------------------------------------------------------------------
%	REQUIRED PACKAGES AND  CONFIGURATIONS
%------------------------------------------------------------------------------

% CONFIGURATIONS
\usepackage{parskip} % For paragraph layout
\usepackage{setspace} % For using single or double spacing
\usepackage{emptypage} % To insert empty pages
\usepackage{multicol} % To write in multiple columns (executive summary)
\setlength\columnsep{15pt} % Column separation in executive summary
\setlength\parindent{0pt} % Indentation
\raggedbottom  

% PACKAGES FOR TITLES
\usepackage{titlesec}
% \titlespacing{\section}{left spacing}{before spacing}{after spacing}
\titlespacing{\section}{0pt}{3.3ex}{2ex}
\titlespacing{\subsection}{0pt}{3.3ex}{1.65ex}
\titlespacing{\subsubsection}{0pt}{3.3ex}{1ex}
\usepackage{color}

% PACKAGES FOR LANGUAGE AND FONT
\usepackage[english]{babel} % The document is in English  
\usepackage[utf8]{inputenc} % UTF8 encoding
\usepackage[T1]{fontenc} % Font encoding
\usepackage[10pt]{moresize} % Big fonts

% PACKAGES FOR IMAGES
\usepackage{graphicx}
\usepackage{transparent} % Enables transparent images
\usepackage{eso-pic} % For the background picture on the title page
\usepackage{subfig} % Numbered and caption subfigures using \subfloat.
\usepackage{tikz} % A package for high-quality hand-made figures.
\usetikzlibrary{}
\graphicspath{{./Images/}} % Directory of the images
\usepackage{caption} % Coloured captions
\usepackage{xcolor} % Coloured captions
\usepackage{amsthm,thmtools,xcolor} % Coloured "Theorem"
\usepackage{float}
\usepackage{tkz-euclide}

% STANDARD MATH PACKAGES
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{bm}
\usepackage[overload]{empheq} % For braced-style systems of equations.
\usepackage{fix-cm} % To override original LaTeX restrictions on sizes

% PACKAGES FOR TABLES
\usepackage{tabularx}
\usepackage{longtable} % Tables that can span several pages
\usepackage{colortbl}

% PACKAGES FOR ALGORITHMS (PSEUDO-CODE)
\usepackage{algorithm}
\usepackage{algorithmic}

% PACKAGES FOR REFERENCES & BIBLIOGRAPHY
\usepackage[colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=black,menucolor=black,runcolor=black,urlcolor=black]{hyperref} % Adds clickable links at references
\usepackage{cleveref}
\usepackage[square, numbers, sort&compress]{natbib} % Square brackets, citing references with numbers, citations sorted by appearance in the text and compressed
\bibliographystyle{abbrvnat} % You may use a different style adapted to your field

% OTHER PACKAGES
\usepackage{pdfpages} % To include a pdf file
\usepackage{afterpage}
\usepackage{lipsum} % DUMMY PACKAGE
\usepackage{fancyhdr} % For the headers
\fancyhf{}

% Input of configuration file. Do not change config.tex file unless you really know what you are doing. 
\input{Configuration_Files/config}

%----------------------------------------------------------------------------
%	NEW COMMANDS DEFINED
%----------------------------------------------------------------------------

% EXAMPLES OF NEW COMMANDS
\newcommand{\bea}{\begin{eqnarray}} % Shortcut for equation arrays
\newcommand{\eea}{\end{eqnarray}}
\newcommand{\e}[1]{\times 10^{#1}}  % Powers of 10 notation

%----------------------------------------------------------------------------
%	ADD YOUR PACKAGES (be careful of package interaction)
%----------------------------------------------------------------------------
\usepackage{pgfplots}
\usepackage{mathrsfs}
\usepackage{cancel}

%----------------------------------------------------------------------------
%	ADD YOUR DEFINITIONS AND COMMANDS (be careful of existing commands)
%----------------------------------------------------------------------------
\newtheorem{definition}{Definition}[chapter]
%\newtheorem{proposition}{Definition}[section]
\DeclareMathOperator*{\subsetminus}{\mathrel{\dot{\subset}}}
%\newcommand{}{}

%----------------------------------------------------------------------------
%	BEGIN OF YOUR DOCUMENT
%----------------------------------------------------------------------------

\begin{document}

\fancypagestyle{plain}{%
\fancyhf{} % Clear all header and footer fields
\fancyhead[RO,RE]{\thepage} %RO=right odd, RE=right even
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}}

%----------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------

\pagestyle{empty} % No page numbers
\frontmatter % Use roman page numbering style (i, ii, iii, iv...) for the preamble pages

\puttitle{
	title=QUANTUM COMPUTATION ON THE TORIC CODE, % Title of the thesis
	name=Alessia Conca Roncari, % Author Name and Surname
	course=Computer Science and Engineering - Ingegneria Informatica, % Study Programme (in Italian)
	ID  = 996809,  % Student ID number (numero di matricola)
	advisor= Prof. Michele Correggi, % Supervisor name
	coadvisor={Massimo Moscolari}, % Co-Supervisor name, remove this line if there is none
	academicyear={2023-24},  % Academic Year
} % These info will be put into your Title page 

%----------------------------------------------------------------------------
%	PREAMBLE PAGES: ABSTRACT (inglese e italiano), EXECUTIVE SUMMARY
%----------------------------------------------------------------------------
\startpreamble
\setcounter{page}{1} % Set page counter to 1

% ABSTRACT IN ENGLISH
\chapter*{Abstract} 
This thesis provides a detailed description of the toric code model, which plays an important
role in the field of quantum computation as a paradigmatic example of quantum error-correction code. 
After a preliminary introductory section on spin observables in Quantum Mechanics, the first chapter of the thesis contains the description of the model of the toric code Hamiltonian followed by the computation of its ground states and excited states, which are classified in terms of their topological properties. In particular, we will show that the excitations are represented by two species of quasi-particles obeying to mutual fractional statisctics. After a brief overview of classical and quantum error correction, the analysis of the anyonic excitations of the toric code done in the first chapter is then used to explicitly describe the strategy behind quantum error correction for logical qubits encoded in the ground states of the toric code Hamiltonian.
\\
\\
\textbf{Keywords:} Quantum computing, Topological codes, Spin lattices, Anyons, Quantum error correction. % Keywords

% ABSTRACT IN ITALIAN
\chapter*{Abstract in lingua italiana}
Questa tesi fornisce una descrizione dettagliata del modello del toric code. Questo modello è importante nel campo della computazione quantistica in quanto rappresenta l'archetipo di codice topologico per la correzione di errori quantistici. Dopo una sezione introduttiva preliminare sulle osservabili di spin in Meccanica Quantistica, il primo capitolo della tesi contiene la descrizione del modello e della sua Hamiltoniana seguito dal calcolo dei suoi stati fondamentali e stati eccitati, i quali vengono classificati in base alle loro proprietà topologiche. In particolare, mostreremo che le eccitazioni sono rappresentate da due tipi di quasi-particelle che obbediscono ad una statistica frazionaria reciproca. Dopo una breve panoramica sulla correzione degli errori classica e quantistica, l'analisi delle eccitazioni anioniche del toric code svolta nel primo capitolo viene utilizzata per descrivere esplicitamente la strategia dietro la correzione degli errori quantistici per qubit logici codificati negli stati fondamentali dell'Hamiltoniana del toric code. 
\\
\\
\textbf{Parole chiave:} Computazione quantistica, Codici topologici, Reti di spin, Correzione degli errori quantistica % Keywords (italian)

%----------------------------------------------------------------------------
%	LIST OF CONTENTS/FIGURES/TABLES/SYMBOLS
%----------------------------------------------------------------------------

% TABLE OF CONTENTS
\thispagestyle{empty}
\tableofcontents % Table of contents 
\thispagestyle{empty}
\cleardoublepage

%-------------------------------------------------------------------------
%	THESIS MAIN TEXT
%-------------------------------------------------------------------------
% In the main text of your thesis you can write the chapters in two different ways:
%
%(1) As presented in this template you can write:
%    \chapter{Title of the chapter}
%    *body of the chapter*
%
%(2) You can write your chapter in a separated .tex file and then include it in the main file with the following command:
%    \chapter{Title of the chapter}
%    \input{chapter_file.tex}
%
% Especially for long thesis, we recommend you the second option.

\addtocontents{toc}{\vspace{2em}} % Add a gap in the Contents, for aesthetics
\mainmatter % Begin numeric (1,2,3...) page numbering







% --------------------------------------------------------------------------
% NUMBERED CHAPTERS % Regular chapters following
% --------------------------------------------------------------------------

\chapter*{Introduction}

Being able to leverage quantum phenomena to perform computations has brought significant 
advancements to the field of quantum computing. Quantum systems possess unique properties promising exponential speedup over classical algorithms for specific tasks \cite{Nie06}. However, realizing such potential 
requires overcoming significant challenges, such as the exposure to
noise of a physical system. As a consequence, quantum error correction has emerged as an important area of research. Traditional error correction techniques developed for classical computers cannot be directly applied to quantum systems due to the intrinsic fragility of quantum information \cite{Cha06}. Therefore, the main goal of quantum error correction is to mitigate errors by encoding quantum information into carefully designed quantum states. Several quantum computing models have been studied theoretically
in order to assess this issue and give access to their practical realizations. 
Among various quantum error correcting codes, topological codes are of particular interest due to their robustness against local perturbations and their ability to encode information in a non-local manner \cite{Kit02}. \newline

The toric code was one of the first topological quantum error correcting codes that has been proposed. It was introduced by Alexei Kitaev in 1997 as a two-dimensional lattice model, which is particularly notable for its robustness against local errors thanks to its topological properties. In fact, what makes the toric code special is the way it exploits the topological features of a quantum system to robustly encode information and protect it from the damaging effects of noise. In particular, not only does the toric code exhibit topological order, which manifests itself through the degeneracy of the ground state manifold and the occurrence of excitations given by quasi-particles obeying to exotic mutual statistics (anyons).\newline

%\newpage
In this thesis, we initially give a brief mathematical description
of spin observables in Quantum Mechanics by studying their mathematical properties. 
These properties are later used to give a precise definition of the toric code model along with the stabilizer operators encoded in its Hamiltonian. Such operators, called vertex and plaquette operators, play a crucial role in the characterization of the ground states of the system, which are the states with the lowest possible energy.
In particular, vertex and plaquette operators are simultaneously diagonalizable. This allows to explicitly compute the ground states, which form a manifold of dimension 4 \cite{Her20}. Such a degeneracy is in fact due to the topological features of the toric code model, which are key in order to encode quantum information in the ground states of the system by providing redundancy. Such topological features of the toric code have a two-fold relevance: on one hand, a quantum computation on it would be protected from local perturbations, and, on the other hand, there would be a natural correction algorithm to implement \cite{Zbi19}. After the discussion of the ground states of the Hamiltonian, we study excited states that can be obtained through the application of string operators. In fact, they contain pairwise excitations: {\it magnetic vorteces} and {\it electric charges}. Ultimately, we focus on giving a brief description of identical particles in Quantum Mechanics including anyons in two dimensional systems and explain how mutual anyonic
statistics arise in the toric code model. Unlike conventional particles, anyons exhibit nontrivial phase changes when exchanged. By leveraging the braiding of anyons, we can encode quantum information in the ground states of the Hamiltonian and perform fault-tolerant operations \cite{Rao01,Rao16}. \newline
In the second part of the thesis, the first sections are dedicated to give an overview of 
classical and quantum error models. In doing so, we focus on error detection and correction
techniques both in the classical and quantum setting. We ultimately aim to build an analogy with the quantum error correction on the toric code. In fact, the last section focuses precisely on explaining why the anyonic excitations derived in the previous section are so important to be able to encode quantum qubits in the ground states of the Hamiltonian and why this is mathematically possible \cite{Zbi19}. \newline 
%Lastly, this section gives a complete overview of possible error scenarios on the toric code in order to explain 
%how error detection and correction are brought out in this context. \newline

In conclusion, this thesis provides a comprehensive description of the 
toric code together with its implications to quantum error correction in topological 
quantum computation. 
Through the careful study of the theoretical features of the toric code model, this work  investigates some
practical applications of quantum information processing and error 
correction methodologies as well as the possibility of effectively perform fault-tolerant 
quantum computation. \newline














%------------------------------------------------------------


\chapter{Toric Code}
\label{ch:chapter_one}%
% The \label{...}% enables to remove the small indentation that is generated, always leave the % symbol.


\section{Spin Observables in Quantum Mechanics}
\label{sec:Observables}

In the context of quantum mechanics, an observable is a quantity that can be observed in a quantum system. Some examples could be: position, momentum or energy of a system. The latter is represented by the Hamiltonian, which not only describes the energy but also encodes the rules that govern the dynamic of the system. 
Formally, an observable is represented by an Hermitian operator over an Hilbert space $\mathscr{H}$.

\begin{definition} (Hilbert space)
	An Hilbert space $\mathscr{H}$ over $\mathbb{C}$ is a complex vector space on $\mathbb{C}$  
	with a scalar product $\langle \cdot \vert \cdot \rangle $: $\mathscr{H} \times \mathscr{H} \rightarrow \mathbb{C}$ and which is complete with respect to the norm induced by the scalar product.
\end{definition}

In particular, a 'spin' observable is a physical quantity associated with the intrinsic angular momentum of elementary particles, such as electrons. The spin is a fundamental property of particles and is characterized by a quantum number typically denoted by $S$, representing the spin quantum number.
In quantum mechanics, spin observables represent the possible measurements that can be made on the spin of a particle. Moreover, the spin is described using spin operators, which are, as anticipated above, hermitian matrices representing the components of the angular momentum of the spin along different directions. 



\subsection{Self-adjointness and unitarity}

We denote as $\mathscr{B}(\mathscr{H})$ the space of bounded linear operators on $\mathscr{H}$.
The self-adjointness of an operator can be stated as follows:

\begin{definition} (Hermitian operator) Let $\mathscr{H}$ be an Hilbert space and  $A$: $\mathscr{H} \rightarrow \mathscr{H}$ be a bounded linear operator. An operator $A$ is called Hermitian if for all $\psi,\phi \in \mathscr{H}$ we have that
\end{definition}

\begin{center}
	$\langle A\psi|\phi \rangle = \langle \psi|A^{\dagger}\phi \rangle = \langle \phi|A\psi \rangle^{*}$.
\end{center}

The symbol $\dagger$ denotes the Hilbert adjoint, which in the case of a finite-dimensional Hilbert space coincides with  the adjoint for matrices, i.e. for $\mathscr{H}$, finite-dimensional, and any $A$ $\in$ $\mathscr{B}(\mathscr{H})$, $A^{\dagger}$ is such that $(A^{\dagger})_{ij}=A_{ij}^*$. A self-adjoint square matrix $A$ of complex numbers, representing a linear operator, is also called hermitian. One important consequence of self-adjointness is that it ensures that the spectrum of the operator is real. Notice also that, for real matrices, it is sufficient to compute only the transpose of the matrix to verify hermiticity. \newline
%Furthermore, as mentioned above, vertex and plaquette operators satisfy the involutory property, which is derived from the unitarity of the matrices representing the vertex and plaquette operators, i.e. $X$ and $Z$ Pauli matrices. \newline 

In order to understand the dynamics of observables, we introduce another important property: unitarity. 
As previously said, observables such as position, momentum and energy are represented by hermitian operators, which ensure the existence of real eigenvalues and orthogonal eigenvectors. Instead, unitarity governs the evolution in time of quantum states and operators. In particular, it ensures that the total probability of all possible outcomes of a measurement remains conserved over time, preserving the fundamental principles of quantum mechanics. 

\begin{definition} (Unitary operator) Let $\mathscr{H}$ be an Hilbert space and let $U \in \mathscr{B}(\mathscr{H})$. We say that $U$ is a unitary operator if for all $\psi,\phi \in \mathscr{H}$ we have that
\end{definition}

\begin{center}
	$\langle U\psi|U\phi \rangle = \langle \psi|\phi \rangle$.
\end{center}

In terms of the conjugate transpose, we can define a complex matrix $U$ to be unitary if $ (U^*)^T=U^{-1}$. We can also define that a real matrix $U$, representing a linear operator, is unitary if $(U)^T = U^{-1}$ or, equivalently, if $(U)^T U=I$. 
%In our case this directly translates to $U^2=1$ beacause for $X$ and $Z$ Pauli matrices we have that $U^T=U$. Note also that one important property of  unitary operators is that their eigenvalues have modulus equal to one.\newline

Overall, self-adjointness and unitarity provide a comprehensive framework for describing the behavior of observables in quantum mechanics.


\subsection{The spectrum}

The spectrum of an observable refers to the set of possible values that can be obtained when measuring the physical quantity represented by the observable. 

\begin{definition}(Spectrum)
	Given an operator $A\in\mathscr{B(\mathscr{H})}$, the spectrum $\sigma(A)$ is the set of $z\in\mathbb{C}$ such that ($A$ - $z$) is not invertible.
\end{definition}

%The trivial spectrum of vertices and plaquette operators will be of fundamental importance to perform fault-tolerant quantum compuations, in particular for measuring whether any error has occurred during computation (see Chapter 3). 


\subsection{Commutation and anticommutation}

Given two observables represented by bounded self-adjoint operators $A$ and $B$, we define the commutator as follows

\begin{center}
	$[A, B] = AB - BA$.
\end{center}

and the anticommutator as

\begin{center}
	$\{A,B\} = AB + BA$.
\end{center}

The two observables commute if

\begin{center}
	$AB = BA$
\end{center}

while, they anticommute if 

\begin{center}
	$AB = - BA$. 
\end{center}


\subsection{Spin-$\frac{1}{2}$ particles example}

In order to exemplify the above properties of the observables, we consider spin-$\frac{1}{2}$ particles {as discussed in \cite{Cor23}}, i.e. electrons, and define the components of the spin in three dimensions. In this case the Hilbert space is bidimensional and the observables can be written in terms of Pauli matrices in the basis $\{ | \frac{1}{2}, \pm \frac{1}{2} \rangle \}$ (spin-up and spin-down) for $\hbar=1$:


\[
\begin{array}{ccc}
	\text{$\sigma_1$} = 
	\begin{pmatrix}
		0 & 1 \\
		1 & 0
	\end{pmatrix} &
	\text{$\sigma_2$} = 
	\begin{pmatrix}
		0 & -i \\
		i & 0
	\end{pmatrix} &
	\text{$\sigma_3$} = 
	\begin{pmatrix}
		1 & 0 \\
		0 & -1
	\end{pmatrix}
\end{array}.
\]

We are also going to consider $\sigma_1=\sigma_x$, $\sigma_2=\sigma_y$ and $\sigma_3=\sigma_z$.
Pauli matrices are self-adjoint and unitary. Moreover they satisfy some specific commuation and anticommutation properties.


\begin{center}
	$[\sigma_i, \sigma_j] = \sigma_i \sigma_j - \sigma_j \sigma_i 
	= 2i\epsilon_{ijk} \sigma_k$
\end{center}

where $\epsilon_{ijk}$ is the Levi-Civita symbol, and \newline


\begin{center}
	$\{\sigma_i, \sigma_j\} = \sigma_i \sigma_j + \sigma_j \sigma_i 
	= 2 \delta_{ij}\mathbb{I}$
\end{center}

where $ \delta_{ij} $ is the Kronecker delta and $\mathbb{I}$ is the identity matrix.


\subsection{Tensor product of Hilbert spaces}

Given two observables $A$ and $B$ acting on a bidimensional Hilbert space, their tensor product $A \otimes B$ over $\mathbb{C}^2 \otimes \mathbb{C}^2$ can be expressed on the corresponding basis: combining the two basis elements of each copy of $\mathbb{C}^2$ we  obtain four combinations:

\[\begin{array}{ccc}
	(e_1 \otimes e_1'), 
	(e_1 \otimes e_2'),
	(e_2 \otimes e_1'),
	(e_2 \otimes e_2')
\end{array}\]

which correspond to:

\[
\begin{array}{ccc}
	\begin{pmatrix}
		1 \\
		0  
	\end{pmatrix} 
	\otimes
	\begin{pmatrix}
		1  \\
		0 
	\end{pmatrix} ,
	
	\begin{pmatrix}
		1 \\
		0  
	\end{pmatrix} 
	\otimes
	\begin{pmatrix}
		0  \\
		1 
	\end{pmatrix} ,
	
	\begin{pmatrix}
		0 \\
		1  
	\end{pmatrix} 
	\otimes
	\begin{pmatrix}
		0  \\
		1 
	\end{pmatrix} ,
	
	\begin{pmatrix}
		0 \\
		1  
	\end{pmatrix} 
	\otimes
	\begin{pmatrix}
		1  \\
		0 
	\end{pmatrix} &
\end{array}.
\]

Then, we can then write:

\begin{center}
  $u = \sum_{j=1}^{2} \sum_{i=1}^{2} c_{ij} (e_i \otimes e_j') = \sum_{j=1}^{4} d_j v_j$
\end{center}

where $c_{ij}$ is a complex coefficient in $\mathbb{C}$. Here $u$ represents a general state  in the tensor product space $\mathbb{C}^2 \otimes \mathbb{C}^2$ in terms of the linear combination of basis vectors $v_j$.


Considering that $A$ acts only an the first Hilbert space $A \otimes \mathbb{I}$ and that $B$ acts only on the second $\mathbb{I} \otimes B$, we can rename:

\begin{center}
	$A \otimes \mathbb{I}$=$A_1$ \\
	$\mathbb{I} \otimes B$=$B_2$
\end{center}

and write the tensor product as a simple product of $A_1$ and $B_2$:

\begin{center}
	$A \otimes B$=$A_1$$B_2$.
\end{center}

This is because the operators acts locally, so we can ignore the identity. \newline
Similarly if we compute the scalar product of two factorized states explicitly, it becomes a simple product of the scalar products between the components of the basis:

\begin{center}
	$(u_1 \otimes w_1) \cdot (u_2 \otimes w_2) = \langle u_1 | w_1 \rangle \langle u_2 | w_2 \rangle$.
\end{center}







%------------------------------------

\newpage
\section{Description of the Model}
\label{sec:Model}

The toric code model is defined on a square lattice with periodic boundary conditions in both directions. These latter characteristics are typical of what is known as a torus topology or simply a torus, after which the model takes name.\newline
Our lattice $\mathcal{L}$, is a subset of $\mathbb{Z}^{2}$, such that each lattice point is identified with a pair of integers. The periodic boundary conditions are imposed by specifying that for any site $(i, j)$ in the lattice, the neighboring sites are going to be: $((i+1)\mathrm{mod}N, j)$, $((i-1)\mathrm{mod} N, j)$, $(i, (j+1)\mathrm{mod}N)$ and $(i, (j-1)\mathrm{mod}N)$, where $N$ is the side-length of the torus. We are also going to consider a dual lattice, which will be denoted as $\mathcal{L}'$ and which is given by 

\[
  \mathcal{L}' = \{ (i\mathrm{mod}N +\frac{1}{2}), (j\mathrm{mod}N +\frac{1}{2})\}.
\]

Each unitary step on the lattice is identified with an edge; given the vertices or lattice points $\vec{v}=(i,j) \in V$ where $V$ coincides with $\mathcal{L}$ and the cells $\vec{p}=(i+\frac{1}{2},j+\frac{1}{2})\in P$ where $P$ coincides with $ \mathcal{L'}$ of the lattice as shown in figure 1.1, we can define the set of all edges for the lattice:

\begin{definition}(Edges of $\mathcal{L}$)
	We define the set of all edges of the lattice as: $E = \{e=(\vec{v_1},\vec{v_2}) \ s.t. \ \vec{v_2}=\vec{v_1}+\hat{e}_1 \ or \ \vec{v_2}=\vec{v_1}+\hat{e}_2 \}$.
\end{definition}
%where $\vec{v_1}$ points to a site $(i, j)$ in $\mathcal{L}$. 

Notice that we can identify each edge $e=((i,j),(i',j')) \in E$ with the vector that points at the middle point of the edge, namely with the vector of coordinates $\vec{e}=(i + (i'-i)/2, j + (j'-j)/2)$. In the rest of the thesis we will make use of this identification without explicit mention. We can also define the set of edges of the dual lattice as:

\begin{definition}(Edges of $\mathcal{L'}$)
	We define the set of all edges of the dual lattice $\mathcal{L'}$ as: $E' = \{e'=(\vec{p_1},\vec{p_2}) \ s.t. \ \vec{p_2}=\vec{p_1}+\hat{e}_1 \ or \ \vec{p_2}=\vec{p_1}+\hat{e}_2 \}$.
\end{definition}

On each edge is located a spin-$\frac{1}{2}$ particle each belonging to a bidimensional Hilbert space $\mathbb{C}^2$. As a consequence we need to define a global Hilbert space for the lattice that takes into account every edge:

\begin{definition}(Space of states)
	The Hilbert space of the system is: $\mathscr{H}= \bigotimes_{e \in E} \mathbb{C}^2$.
\end{definition}

For each cell in $\mathcal{L}$ we are going to consider two spins, therefore the total number of spins is to $2N^2$, where $N^2$ represents the total number of cells in $P$ and vertices in $V$ and $N$ the side length of the lattice. \newline
Notice that, all these spins exhibit are identical particles, which will play an important role to know in the next sections in order to study the behaviour of the system.

%\afterpage{
\begin{figure}
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=blue!50] at (0,0.5) {};
						\else
						\ifnum\intj=-2
						\draw node[draw,circle,fill=blue!50] at (0,-0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=red!50] at (0.5,0) {};
						\else
						\ifnum\inti=-2
						\draw node[draw,circle,fill=red!50] at (-0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						\fi
						
						% Draw circles at the other two sides
						\ifnum\intj=-2
						\draw node[draw,circle,fill=blue!50] at (0,-0.5) {};
						\fi
						
						\ifnum\inti=-2
						\draw node[draw,circle,fill=red!50] at (-0.5,0) {};
						\fi
					\end{scope}
				}
			}
			
			% Define vertices
			\coordinate (A) at (-3,-3);
			\coordinate (B) at (-1,-1);
			
			% Draw vector
			\draw[->, line width=1.1pt] (A) -- (B) node[left] {\large $\vec{v}$};
			
			
			% Define vertices
			\coordinate (A) at (-3,-3);
			\coordinate (B) at (-1.5,0.5);
			
			% Draw vector
			\draw[->, line width=1.1pt] (A) -- (B) node[right] {\large $\vec{p}$};
			
			% Define vertices
			\coordinate (A) at (-3,-3);
			\coordinate (B) at (-3,-2);
			
			% Draw vector
			\draw[->, line width=1.1pt] (A) -- (B) node[midway, left] {\large $\vec{e_2}$};
			
			
			% Define vertices
			\coordinate (A) at (-3,-3);
			\coordinate (B) at (-2,-3);
			
			% Draw vector
			\draw[->, line width=1.1pt] (A) -- (B)  node[midway, below] {\large $\vec{e_1}$};
			
			
			
			
		\end{tikzpicture}
	\end{center}
	
	\caption{Square lattice with boundary conditions. The spins are represented with an empty circle while circles shaded in blue/red represent the boundary conditions. $\hat{e}_1$ and $\hat{e}_2$ are unitary vectors identifying the coordinate system used to identify the sites of the lattice through vectors $\vec{v}$ and $\vec{p}$ with application point in the origin of the coordinate system.
	In the following sections we are going to indicate the boundary conditions in gray.}
	\label{fig:lattice}
\end{figure}
%}

\newpage
The key part of the Toric Code are the so called \textit{vertex} and \textit{plaquette} operators that are going to be placed, respectively, on the vertices and cells of $\mathcal{L}$. Such operators can be defined formally as in definition 1.10 and implemented by means of Pauli matrices as exemplified in figure 1.2. In order to give definition 1.10 we define the following:


\begin{figure}
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {-1,...,-1} %column
			{
				
				\draw[blue!50, line width=1.5mm] (\i,0.5) -- (\i,1.5);
				\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,0.5) {};
				\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,1.5) {};
				
			}
			\foreach \j in {1,...,1}
			{
				
				\draw[blue!50, line width=1.5mm] (-1.5, \j) -- (-0.5, \j);
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z},,label=\textbf{$A_{\vec{v}}$}] at (-1.5,\j) {};
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z}] at (-0.5,\j) {};
				
			}
			
			
			\foreach \i in {2,...,2}
			{
				
				\draw[red!70, line width=1.5mm] (\i,-1) -- (\i,0);
				\node[draw, circle, fill=red!70,label=center:\textbf{X}] at (\i,-0.5) {};
				
			}
			\foreach \j in {-1,...,-1}
			{
				
				\draw[red!70, line width=1.5mm] (2, \j) -- (1, \j);
				\draw node[draw,circle,fill=red!70,label=center:\textbf{X}] at (1.5,\j) {};
				
			}
			\foreach \i in {1,...,1}
			{
				
				\draw[red!70, line width=1.5mm] (\i,-1) -- (\i,0);
				\node[draw, circle, fill=red!70,label=center:\textbf{X},label=left:\textbf{$B_{\vec{p}}$}] at (\i,-0.5) {};
				
			}
			\foreach \j in {0,...,0}
			{
				
				\draw[red!70, line width=1.5mm] (2, \j) -- (1, \j);
				\draw node[draw,circle,fill=red!70,label=center:\textbf{X}] at (1.5,\j) {};
				
			}
			
		\end{tikzpicture}
	\end{center}
	
	\vspace*{1cm}
	
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {-1,...,-1} %column
			{
				
				\draw[blue!50, line width=1.5mm] (\i,0.5) -- (\i,1.5);
				\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,0.5) {};
				\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,1.5) {};
				
			}
			\foreach \j in {1,...,1}
			{
				
				\draw[blue!50, line width=1.5mm] (-1.5, \j) -- (-0.5, \j);
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z},label=\textbf{$A_{\vec{v}}$}] at (-1.5,\j) {};
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z} ] at (-0.5,\j) {};
				
			}
			
			
			
			
			\foreach \i in {1.5,...,1.5}
			{
				
				\draw[red!70, line width=1.5mm] (\i,-1) -- (\i,0);
				\node[draw, circle, fill=red!70,label=center:\textbf{X},label=left:\textbf{$B_{\vec{p}}$}] at (\i,0) {};
				\node[draw, circle,fill=red!70,label=center:\textbf{X}] at (\i,-1) {};
				
			}
			\foreach \j in {-0.5,...,-0.5}
			{
				
				\draw[red!70, line width=1.5mm] (2, \j) -- (1, \j);
				\draw node[draw,circle,fill=red!70,label=center:\textbf{X}] at (1,\j) {};
				\draw node[draw,circle,fill=red!70,label=center:\textbf{X} ] at (2,\j) {};
				
			}
			
			
			
		\end{tikzpicture}
	\end{center}
	
	\caption{In the first picture: vertex (blue) and plaquette (red) operators applied in a vertex and cell of $\mathcal{L}$ respectively. In the second picture: vertex (blue) and plaquette (red) operators applied in a vertex of $\mathcal{L}$ and a vertex of $\mathcal{L'}$, respectively.}
	\label{fig:operators}
\end{figure}

\begin{definition} (Edge operator) 
	We define a generic operator $A$ acting on an edge $e$ of $\mathcal{L}$ as: $A_e$=$A_{(i+\frac{i'-i}{2}, j+\frac{j'-j}{2})}$ where the tuples $(i,j),(i',j')$ uniquely identify an edge $e\in E$.
\end{definition}

\begin{definition} (Groups of neighbouring spins of $\mathcal{L}$) We define the quartets of spins sorrounding a vertex $\vec{v}$ and a plaquette $\vec{p}$ of $\mathcal{L}$, respectively, as the following groups of spins: ${star(\vec{v})}=\{ \vec{v} \pm \frac{1}{2}\hat{e}_1, \vec{v} \pm \frac{1}{2}\hat{e}_2\}$ and ${bdy(\vec{p})} =\{ \vec{p} \pm \frac{1}{2}\hat{e}_1, \vec{p} \pm \frac{1}{2}\hat{e}_2 \} $.
\end{definition}

Then we can define vertex and plaquette operators as:

\begin{definition} (Vertex and Plaquette operators) Given a vertex $\vec{v}$ and a plaquette $\vec{p}$ we can define, respectively, vertex and plaquette operators as products over Pauli operators, each acting locally on four neighbouring spins of $\mathcal{L}$
	
\begin{center}
	$ A_{\vec{v}} = \prod_{e \in star(\vec{v})} Z_e $ 
	
	$ B_{\vec{p}} = \prod_{e \in bdy(\vec{p})} X_e $.
\end{center}
%e \ s.t.\ \vec{v}_1 \in star(\vec{v})

Where we have defined each edge operator $Z_e$ and $X_e$ to be equal to the following tensor proucts:

\begin{center}
	
	$Z_e = \mathbb{I}_{\mathcal{E} \setminus  e} \otimes \sigma^z_{e}$ 
	
	$X_e = \mathbb{I}_{\mathcal{E} \setminus  e} \otimes \sigma^x_{e} $ .
	
\end{center}
\end{definition}

For the sake of simplicity, we will usually omit the tensor product because there is no risk of ambiguity in the interpretation. In fact, since the vertex and plaquette operators act locally, we can omit writing down the tensor product with the identity for sites that are not part of the support of the operator. 
%Thus, we can simply rewrite them by means of the product of the Pauli matrices that act on the quartets of spins indexed as $j \in \mathrm{star(v)}$ and $j \in \mathrm{bdy(p)}$. 
 



All the elements that constitute the model of the toric code are brought together by its Hamiltonian. definition 1.2 describes the Hamiltonian of the toric code 
{according to \cite{Kit02}}. For recent reviews on the subject see \cite{Her20}.

\begin{definition} (Toric Code Hamiltonian) Given vertex and plaquette operators, we can define the following Hamiltonian for the system:
\end{definition}

\begin{center}
	
	$H = -\sum_{\vec{v} \in V}
	A_{\vec{v}} - \sum_{\vec{p} \in P} B_{\vec{p}} $
	
\end{center}

Each one of the $A_{\vec{v}}$ and $B_{\vec{p}}$ operators that appear in the Hamiltonian share some important properties. Firstly, notice that $A_{\vec{v}}$ and $B_{\vec{p}}$ operators are Hermitian and square to the identity. Given the considerations made in definition 1.2 and 1.3 for bounded operators, we can easily prove the first following proposition:

\begin{proposition} (Properties of $A_{\vec{v}}$ and $B_{\vec{p}}$ operators)
The operators $A_{\vec{v}}$ and $B_{\vec{p}}$ are involutions, i.e. $A_{\vec{v}}^2= B_{\vec{p}}^2=\mathbb{I}$.
\end{proposition}
	
\textit{Proof.}
We know that the operator $A_{\vec{v}} = \prod_{star(\vec{v})} Z_e$ and that $ B_{\vec{p}} = \prod_{bdy(\vec{p})} X_e  $ .\newline
Firstly, recall the form of the $\sigma_x$ and $\sigma_z$ matrices representing the Pauli gates $X$ and $Z$:



\[
\text{Z = $\sigma_z$} =
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix},
\]


\[
\text{X = $\sigma_x$} =
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix}.
\]


It can be proved that they are Hermitian:\newline

\[
\text{$( \sigma_z )^{\dagger}$} = 
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix} ^\dagger =
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix}^T =
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix}
= \text{$ \sigma_z $},
\]


\[
\text{$( \sigma_x )^{\dagger}$} = 
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix} ^\dagger =
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix}^T =
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix}
= \text{$ \sigma_x $}.
\]

since Pauli matrices are real matrices and thus $A^{\dagger}=A^T$.
%Then, knowing that $[\sigma_i,\sigma_j]=0 \ for \ i=j$ we can write:
Hence, by the properties of the tensor product of Hilbert spaces,

\begin{center}
	$(A_{\vec{v}})^{\dagger} = (\sigma_{x_1} \sigma_{x_2} \sigma_{x_3} \sigma_{x_4})^{\dagger} = \sigma_{x_1}^{\dagger} \sigma_{x_2}^{\dagger} \sigma_{x_3}^{\dagger} \sigma_{x_4}^{\dagger} = \sigma_{x_1} \sigma_{x_2} \sigma_{x_3} \sigma_{x_4} = A_{\vec{v}}$ \newline
	
	$(B_{\vec{p}})^{\dagger} = (\sigma_{z_1} \sigma_{z_2} \sigma_{z_3} \sigma_{z_4})^{\dagger} = \sigma_{z_1}^{\dagger} \sigma_{z_2}^{\dagger} \sigma_{z_3}^{\dagger} \sigma_{z_4}^{\dagger} = \sigma_{z_1} \sigma_{z_2} \sigma_{z_3} \sigma_{z_4} = B_{\vec{p}}$ \newline
\end{center}

Moreover, since the square of all Pauli matrices is the identity:\newline

\[
\text{$( \sigma_z )^{2}$} = 
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix} \cdot
\begin{pmatrix}
	1 & 0 \\
	0 & -1
\end{pmatrix} =
\begin{pmatrix}
	1 & 0 \\
	0 & 1
\end{pmatrix}
= \text{$\mathbb{I}$}
\]


\[
\text{$( \sigma_x )^{2}$} = 
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix} \cdot
\begin{pmatrix}
	0 & 1 \\
	1 & 0
\end{pmatrix} =
\begin{pmatrix}
	1 & 0 \\
	0 & 1
\end{pmatrix}
= \text{$\mathbb{I}$}
\]\newline


Then, again $A_{\vec{v}}$ and $B_{\vec{p}}$ are involutions \newline

\begin{center}
	$(A_{\vec{v}})^{2} = (\sigma_{x_1} \sigma_{x_2} \sigma_{x_3} \sigma_{x_4})^{2} = \sigma_{x_1}^2 \sigma_{x_2}^2 \sigma_{x_3}^2 \sigma_{x_4}^2 = \mathbb{I}$ 
	
	$(B_{\vec{p}})^{2} = (\sigma_{z_1} \sigma_{z_2} \sigma_{z_3} \sigma_{z_4})^{2} = \sigma_{z_1}^2 \sigma_{z_2}^2 \sigma_{z_3}^2 \sigma_{z_4}^2 = \mathbb{I}$
\end{center}

\hfill $\square$

Given proposition 1.1, we can now further characterize the spectrum of the opeartors. First we prove the property of involution.

\begin{proposition} (Eigenvalues of $A_{\vec{v}}$ and $B_{\vec{p}}$ operators) Let $A \in \mathscr{B(\mathscr{H})}$ be a self-adjoint unitary operator on a finite-dimansional Hilbert space and such that $A^2=\mathbb{I}$, thwn $\sigma(A) \in \{-1,+1\}$.
\end{proposition}


\textit{Proof.}\newline
%Given the Self-adjointness and involutory proof in 1.1, we firstly prove that vertex and plaquette operators have real eigenvalues: 

Let us start by writing the expression for the eigenvalues $A_{\vec{v}} |\xi \rangle = \lambda |\xi \rangle$ and take as hypothesis that $|\xi \rangle \neq 0$. Then, by means of the scalar product:

\begin{center}
	$\langle \xi|A_{\vec{v}}|\xi \rangle = \lambda \langle \xi | \xi \rangle$,
	
	$\lambda = \frac {\langle \xi|A_{\vec{v}}\xi \rangle}{\langle \xi |\xi \rangle}$ = $\frac {(\langle A_{\vec{v}}\xi|\xi \rangle)^*}{||\xi||^2}$ = $\frac {\langle \xi|A_{\vec{v}}^{\dagger}\xi \rangle}{||\xi||^2}$ = $\lambda^*$ 
\end{center}

Notice that we have applied antilinearity of the adjoint in the penultimate equality: 

\begin{center}
	$(\langle \xi|A_{\vec{v}}^{\dagger}|\xi \rangle)^{\dagger}$ = $|\xi\rangle^{\dagger} (A_{\vec{v}}^{\dagger})^{\dagger} \langle\xi|^{\dagger}$ = $\langle \xi|A_{\vec{v}}|\xi \rangle^*$.  
\end{center}

Therefore, we have derived that the eigenvalues of $A_{\vec{v}}$ are $\lambda = \lambda^*$, which implies that they must be real.

%Using hermiticity with the fact that $(Av)^2=I$ we can derive the unitarity of $Av$ and state that $Av Av^{\dagger} = Av^{\dagger} Av = (Av)^2 = I$. \newline
%Given the property of unitarity, which states that the corresponding eigenvalues of the operator have modulus equal to one,:\newline 

Then we exploit unitarity while taking as hypothesis that $|\xi \rangle \neq 0$. 
We write the expression $A_{\vec{v}} |\xi \rangle = \lambda |\xi \rangle$ and its self-adjoint $\langle \xi| A_{\vec{v}}^{\dagger} = \lambda^* \langle \xi|$. Recall that $A_{\vec{v}}^{\dagger}=A_{\vec{v}}^{-1}$, thus by means of the scalar product we obtain 

\begin{center}
	$\langle \xi|A_{\vec{v}} A_{\vec{v}}^{\dagger}|\xi\rangle = \lambda \lambda^* \langle \xi |\xi \rangle$
	
	$\langle \xi|I|\xi \rangle = \lambda \lambda^* \langle \xi |\xi \rangle$
	
	$\langle \xi|\xi \rangle = \lambda \lambda^* \langle \xi |\xi \rangle $
	
	$ \lambda \lambda^* = 1 $
	
	$ |\lambda|^2 = 1 $
\end{center}

Which means that the eigenvalues of $A_{\vec{v}}$ have modulus equal to one, as expected. Though, this can happen for two real choices of $\lambda$ which are $+1$ and $-1$.
Therefore, putting together hermiticity and unitarity, 

\begin{center}
$\begin{cases}
	 \lambda = \lambda^* \\
	 |\lambda|^2 = 1 
\end{cases}$
\end{center}

we obtain that the only two remaining possibilities for the eigenvalues of $A_{\vec{v}}$ are $\pm 1$. \newline

The same reasoning can be carried out for the plaquette operators.

\hfill $\square$ 

Given the result of proposition 1.2, is easy to find the spectrum of the operators: 

\begin{proposition} (Spectrum of $A_{\vec{v}}$ and $B_{\vec{p}}$ operators) The spectrum of $A_{\vec{v}}$ and $B_{\vec{p}}$ operators is equal to $\{-1,+1\}$. 
\end{proposition}

\textit{Proof.}\newline
If we choose the eigenvalues of the $\sigma^z$ and $\sigma^x$ making up, respectively, the vertex and plaquette operator, to be positive and equal to +1 we obtain the following eigenvalues assosciated with the vertex and plaquette operator:

\begin{center}
	$A_{\vec{v}} |\psi\rangle = |\psi\rangle$ \\
	$B_{\vec{p}} |\psi\rangle = |\psi\rangle$.
\end{center}

On the other hand, if we choose an odd numer of eigenvalues, associated to the $\sigma^z$ and $\sigma^x$, to be equal to -1 we will obtain the following:

\begin{center}
	$A_{\vec{v}} |\psi\rangle = -|\psi\rangle$ \\
	$B_{\vec{p}} |\psi\rangle = -|\psi\rangle$
\end{center}

Overall, if we compute the corresponding eigenvalue of $A_{\vec{v}}$ (or $B_{\vec{p}}$), this can either assume value $-1$ or $+1$ according to the fact that the Pauli matrices that make up the operator anticommute, respectively, with an odd or even number of edges.

\hfill $\square$

Given proposition 1.3, we can in fact prove that the following relationships between vertex and plaquette operators holds:

\begin{proposition} (Commutation of $A_{\vec{v}}$ and $B_{\vec{p}}$ operators) The commutator between two vertex or plaquette operators is always zero.

\begin{center}
	$[A_{\vec{v}},A_{\vec{v}}]=0$ 
\end{center}

\begin{center}
	$[B_{\vec{p}},B_{\vec{p}}]=0$ 
\end{center}

\begin{center}
	$[A_{\vec{v}},B_{\vec{p}}]=0$ 
\end{center}
	
\end{proposition}


%\begin{proposition} (Anticommutation of $A_{\vec{v}}$ and $B_{\vec{p}}$ operators) The operator $A_{\vec{v}}$ anticommutes with the operator $B_{\vec{p}}$ whenever the intersection between $star(\vec{v})$ and $bdy(\vec{p})$ contains an odd number of edges. 
%\end{proposition}


\textit{Proof.}\newline 
%Av commutes with itself.\newline
%Bp commutes with itself.\newline
%Av commutes with Bp for an even number of edges.\newline
Fix the origin of the coordinate system in the bottom left corner of the lattice as shown in figure 1.3. 

\begin{figure}
\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-3,-2.5,...,3}
		{
			\draw[dashed] (\i,-3) -- (\i,3);
		}
		\foreach \j in {-3,-2.5,...,3}
		{
			\draw[dashed] (-3,\j) -- (3,\j);
		}
		
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-3,-3) grid (3,3);
		\foreach \i in {-2.5,...,2.5}
		{
			\foreach \j in {-2.5,...,2.5}
			{
				
				
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=2
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=2
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		\foreach \i in {-1,...,-1} %column
		{
			
			\draw[blue!50, line width=1.5mm] (\i,0.5) -- (\i,1.5);
			\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,0.5) {};
			\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,1.5) {};
			
		}
		\foreach \j in {1,...,1}
		{
			
			\draw[blue!50, line width=1.5mm] (-1.5, \j) -- (-0.5, \j);
			\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z},label=\textbf{Av}] at (-1.5,\j) {};
			\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z} ] at (-0.5,\j) {};
			
		}
		
		
		
		
		\foreach \i in {1.5,...,1.5}
		{
			
			\draw[red!70, line width=1.5mm] (\i,-1) -- (\i,0);
			\node[draw, circle, fill=red!70,label=center:\textbf{X},label=left:\textbf{Bp}] at (\i,0) {};
			\node[draw, circle,fill=red!70,label=center:\textbf{X}] at (\i,-1) {};
			
		}
		\foreach \j in {-0.5,...,-0.5}
		{
			
			\draw[red!70, line width=1.5mm] (2, \j) -- (1, \j);
			\draw node[draw,circle,fill=red!70,label=center:\textbf{X}] at (1,\j) {};
			\draw node[draw,circle,fill=red!70,label=center:\textbf{X} ] at (2,\j) {};
			
		}
		
		% Define vertices
		\coordinate (A) at (-3,-3);
		\coordinate (B) at (-1,1);
		
		% Draw vector
		\draw[->, line width=1.1pt] (A) -- (B) node[right] {$\vec{v}$};
		
		
		% Define vertices
		\coordinate (A) at (-3,-3);
		\coordinate (B) at (1.5,-0.5);
		
		% Draw vector
		\draw[->, line width=1.1pt] (A) -- (B) node[right] {$\vec{p}$};
		
		
		
		
		
		
		% Define vertices
		\coordinate (A) at (-3,-3);
		\coordinate (B) at (-3,-2);
		
		% Draw vector
		\draw[->, line width=1.1pt] (A) -- (B) node[midway, left] {\large $\vec{e_2}$};
		
		
		% Define vertices
		\coordinate (A) at (-3,-3);
		\coordinate (B) at (-2,-3);
		
		% Draw vector
		\draw[->, line width=1.1pt] (A) -- (B)  node[midway, below] {\large $\vec{e_1}$};
		
		
		
	\end{tikzpicture}
\end{center}

\caption{Vertex and plaquette operators according to the coordinate system with origin in (0,0). Here the plaquette operator is implemented on $\mathcal{L}'$ in order to coherently define its edges from the point of view of $\mathcal{L}$ using vector $\vec{v}$.}
\label{fig:coordinate_system}
\end{figure}


Then, we can define the two vectors representing the site of application of the vertex and plaquette operator, respectively over the lattice $\mathcal{L}$ and dual lattice $\mathcal{L}'$ \newline

\begin{center}
	$\vec{v}$= $n\hat{e_1} + m\hat{e_2}$, where $n,m \in \mathbb{Z}$ 
	
	$\vec{p}$= $(n + \frac{1}{2}) \hat{e_1} + (m + \frac{1}{2}) \hat{e_2}$, where $n,m \in \mathbb{Z}$.
\end{center}

Rewrite the operators as follows: \newline

\begin{center}
	
	$A_{\vec{v}} = \sigma^z_{\vec{v}+\frac{1}{2}\hat{e_1}} \sigma^z_{\vec{v}+\frac{1}{2}\hat{e_2}} \sigma^z_{\vec{v}-\frac{1}{2}\hat{e_1}} \sigma^z_{\vec{v}-\frac{1}{2}\hat{e_2}}$ 
	
	$B_{\vec{p}} = \sigma^x_{\vec{p}+\frac{1}{2}\hat{e_1}} \sigma^x_{\vec{p}+\frac{1}{2}\hat{e_2}} \sigma^x_{\vec{p}-\frac{1}{2}\hat{e_1}} \sigma^x_{\vec{p}-\frac{1}{2}\hat{e_2}}$.
	
\end{center}

In order to simplify the calculations we rewrite $B_{\vec{p}}$ on the lattice $\mathcal{L}$ by rewriting the indeces in terms of vector $\vec{v}$ \newline

\begin{center}
	$(n\hat{e_1} + m\hat{e_2}) + \frac{1}{2}\hat{e_2}= n\hat{e_1} + (m+\frac{1}{2}\hat{e_2})$
	
	$(n\hat{e_1} + m\hat{e_2}) + \frac{1}{2}\hat{e_1}= (n+ \frac{1}{2})\hat{e_1} + m\hat{e_2}$
	
	$(n\hat{e_1} + m\hat{e_2}) + \frac{1}{2}\hat{e_1}+\hat{e_2}= (n+ \frac{1}{2})\hat{e_1} + (m + 1)\hat{e_2}$
	
	$(n\hat{e_1} + m\hat{e_2}) + \frac{1}{2}\hat{e_2}+\hat{e_1}= (n+ 1)\hat{e_1} + (m + \frac{1}{2})\hat{e_2}$.
\end{center}


Then the $B_{\vec{p}}$ operator becomes: \newline

\begin{center}
	
	$B_{\vec{p}} = \sigma^x_{n\hat{e_1} + (m+\frac{1}{2}\hat{e_2})} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + (m + 1)\hat{e_2}} \sigma^x_{(n+ 1)\hat{e_1} + (m + \frac{1}{2})\hat{e_2}}$. \newline
	
\end{center}

%and the Hamiltonian can be written by grouping the indices: \newline

%\begin{center}
	
%	$H = - \sum_{m,n \in \mathbb{Z}} \{ 
%	\sigma^z_{(n+\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m+\frac{1}{2})\hat{e_2}} \sigma^z_{(n-\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m-\frac{1}{2})\hat{e_2}} +
%	\sigma^x_{n\hat{e_1} + (m+\frac{1}{2}\hat{e_2})} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + (m + 1)\hat{e_2}} \sigma^x_{(n+ 1)\hat{e_1} + (m + \frac{1}{2})\hat{e_2}} \} $.\newline
	
%\end{center}

Now calcuate the commutator $[A_{\vec{v}},B_{\vec{p}}] = A_{\vec{v}}B_{\vec{p}} - B_{p}A_{v}$ by focusing on the first term: \newline

\begin{center}
	
	$ A_{\vec{v}}B_{\vec{p}} =
	\sigma^z_{(n+\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m+\frac{1}{2})\hat{e_2}} \sigma^z_{(n-\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m-\frac{1}{2})\hat{e_2}} $ $\cdot$
	
	$\sigma^x_{n\hat{e_1} + (m+\frac{1}{2}\hat{e_2})} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + (m + 1)\hat{e_2}} \sigma^x_{(n+ 1)\hat{e_1} + (m + \frac{1}{2})\hat{e_2}}$. \newline
	
\end{center}


Matrices do not always commute but for Pauli matrices we have the following commutation relationship :
\newline

\begin{center}
	$\sigma^x_{\vec{v}}\sigma^z_{\vec{v}'} = \sigma^z_{\vec{v}'} \sigma^x_{\vec{v}} + 2 \sigma^x_{\vec{v}}\sigma^z_{\vec{v}'} \delta_{\vec{v} \vec{v}'}$\newline
\end{center}

where $\hspace{1cm} \delta_{\vec{v} \vec{v}'} =$
$\begin{cases}
	1, \hspace{1cm} if \hspace{1cm}  \vec{v} = \vec{v}'\\
	0, \hspace{1cm} if \hspace{1cm} \vec{v} \neq \vec{v}'
\end{cases}$\newline

which states that 	$\sigma^x_{\vec{v}}\sigma^z_{\vec{v}'}$ commutes for $\vec{v} \neq \vec{v}'$   but anticommutes for $\vec{v} = \vec{v}'$. This is follows from the anticommutation relationship of Pauli matrices $\sigma^x \sigma^z = - \sigma^x \sigma^z$. Thus, for an even numer of overlapping edges the commutator becomes:\newline

\begin{center}
	
	$[A_{\vec{v}},B_{\vec{p}}] = 2
	\sigma^x_{n\hat{e_1} + (m+\frac{1}{2}\hat{e_2})} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^x_{(n+ \frac{1}{2})\hat{e_1} + (m + 1)\hat{e_2}} \sigma^x_{(n+ 1)\hat{e_1} + (m + \frac{1}{2})\hat{e_2}} \cdot
	\sigma^z_{(n+\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m+\frac{1}{2})\hat{e_2}} \sigma^z_{(n-\frac{1}{2})\hat{e_1} + m\hat{e_2}} \sigma^z_{n\hat{e_1}+(m-\frac{1}{2})\hat{e_2}} $. \newline

\end{center}
Instead, for an odd number of edges the commutator vanishes: $[A_{\vec{v}},B_{\vec{p}}]=0$.

%These calculations conclude that $A_{v},B_{p}$ commute for an even numer of edges but anticommute for an odd number of edges.
In the same way, we notice that two vertex/plaquette operators applied on different sites always commute; this is because they either do not share any edge or they share only one.\newline


\hfill $\square$

Now that we have described the toric code model and its operators, we proceed to compute its ground state, which is at the heart of its fault-tolerant behaviour. The ground state arises from the interaction of vertex and plaquette operators acting on the system's lattice. Through the characterization of these operators and the understanding of their role in enforcing some additional constraints, we gain insight into the structure of the ground state manifold. \newline
In the following section, we derive the unique features of the ground state, including its topological order. \newline 

%--------------



















\newpage
\section{Ground States}
\label{sec:GS}

The ground states of the toric code represent the system's lowest energy configurations. What makes these ground states particularly intriguing is its highly degenerate nature, meaning that there are numerous distinct configurations that all share the same minimum energy. 
The ground states exhibit topological order, characterized by non-local correlations between spins \cite{Kit02}. This means that the model is robust  even when the system is subjected to local perturbations.  In fact, quantum entanglement between spins is not confined to neighboring pairs, instead, it extends over long distances and involves collective behaviours of spins that cannot be understood by considering them individually.
Not only, as we will see, these features are intimately related to the underlying topology of the torus. This topological protection ensures also the robustness of quantum information against local perturbations, giving the toric code the potential to be feasibly applied in quantum information processing (see Chapter 3).\newline

We start by explicitly defining the ground state by making use of the properties of the vertex and plaquette operators that we have derived in the previous section.

\begin{proposition} (Ground states) The ground states of the toric code Hamiltonian are the simultaneous $+1$ eigenstates of all the $A_{\vec{v}}$ and $B_{\vec{p}}$ operators. 
\end{proposition}

\textit{Proof.}\newline 
Recall the form of the Hamiltonian as given in section 1.3:

\begin{center}
	
	$H = -\sum_{\vec{v} \in V}
	A_{\vec{v}} - \sum_{\vec{p} \in P} B_{\vec{p}} $
	
\end{center}

we already know that commuting hermitian matrices are simultaneously diagonalizable, moreover $A_{\vec{v}} $ and $B_{\vec{p}} $ operators commute for an even number of edges, thus there exists a common base of eigenvectors with their respective $\lambda_{\vec{v}}$ and $\lambda_{\vec{p}}$ eigenvalues. We also know from proposition 1.2 that such eigenvalues can assume two values $\{-1,+1\}$ due to the specific properties of our operators.

To determine the ground state of the Hamiltonian we have to determine the minimum energy of the system. Therefore we compute all the possible combinations of the eigenvalues associated to the vertex and palquette operators to obtain the following range of values:

\begin{center}
	$\sigma( H) =$
	$\begin{cases}
		2N^2, \hspace{1cm} if \ all\ \lambda_{\vec{v}}= \lambda_{\vec{p}}=1, \  \forall \ \vec{v} \in V , \vec{p} \in P\\
		\dots\\
		intermediate \ energies,\\
		\dots\\
		-2N^2+1\\
		-2N^2, \hspace{1cm} if \ all\ \lambda_{\vec{v}}= \lambda_{\vec{p}}=1, \  \forall \ \vec{v} \in V, \vec{p} \in P
	\end{cases}$
	
\end{center}

The minimum is reached at $-2N^2$ on the eigenstates  associated to the eigenvalues $\lambda_{\vec{v}}= \lambda_{\vec{p}}=1, \  \forall \ \vec{v} \in V, \vec{p} \in P$.
Such states form the ground state manifold of the system.\newline

\hfill $\square$


In order to determine which are the admissible configurations of eigenstates that we can use to form the ground state, we treat the $A_{\vec{v}} $ and $B_{\vec{p}} $ operators as constraint equations over the configuration space.
As a consequence, all of our configurations will have to satisfy the two following conditions:

\begin{equation}
	A_{\vec{v}} |\psi\rangle = +1|\psi\rangle
\end{equation}

\begin{equation}
	B_{\vec{p}} |\psi\rangle = +1|\psi\rangle
\end{equation}

This means that configuration $|\psi\rangle$ needs to be be an eigenvector for all the vertices and plaquette operators. \newline
In order to satisfy equation (1.1), we look for loop configurations such that if we apply $A_{\vec{v}} $ to that state, the result would still yield an overall positive value.\newline
Graphically, we identify the loop configurations through strings of 'occupied' edges (shaded in black in figure 1.4 and 1.5).
%each identified as a qubit in configuration $|1\rangle$.

\begin{definition}(Occupied edges)
	Given a state $|\psi\rangle $, we say that in the state $|\psi\rangle $ the edge $e$ of the lattice is occupied if $\sigma^z_e |\psi\rangle  = - |\psi\rangle $.
\end{definition}

Then, if we apply $A_{\vec{v}} $ at one of the open ends of such strings, we have two possibilities: leaving the string of occupied edges open (figure 1.4) or closing the string over the $A_{\vec{v}} $ operator (figure 1.5).
In the first case, what we get is $\sigma^{z} |\psi\rangle$ at one endpoint of the string, which implies obtaining $-1|\psi\rangle$ eigenvalue for that endpoint; as a result we violate constraint (1). In the second case, instead, we end up with positive eigenvalues for each edge, this is because the negative signs obtained at the endpoints cancel themselves out. Overall, in order to respect contraint (1) we are interested only in closed loops on $A_{\vec{v}} $. Notice that such loops will always have an even length.{\cite{Her20}}

%drawings closed/open loop with Av
\begin{figure}
	
	\begin{center}
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {-2,...,-2}
			{
				\draw[black, line width=1.5mm] (\i,-0.5) -- (\i,1.5);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};
				
				\draw[blue!50, line width=1.5mm] (\i,1.5) -- (\i,2.5);
				\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,1.5) {};
				\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,2.5) {};
				
				
			}
			
			\foreach \j in {2,...,2}
			{
				
				\draw[blue!50, line width=1.5mm] (-2.5, \j) -- (-1.5, \j);
				
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z},label=north:\textbf{Av}] at (-2.5,\j) {};
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z}] at (-1.5,\j) {};
				
			}
			
			
		\end{tikzpicture}
	\end{center}
	
	\caption{Operator $A_v$ applied on an open string of occupied edges.}
	\label{fig:Aveigen2}
\end{figure}




\begin{figure}
	
\begin{center}
\begin{tikzpicture}
	% Draw dashed lines
	\foreach \i in {-3,-2.5,...,3}
	{
		\draw[dashed] (\i,-3) -- (\i,3);
	}
	\foreach \j in {-3,-2.5,...,3}
	{
		\draw[dashed] (-3,\j) -- (3,\j);
	}
	
	
	
	% Draw solid grid and nodes with circles in the middle of each side
	\draw[step=1cm] (-3,-3) grid (3,3);
	\foreach \i in {-2.5,...,2.5}
	{
		\foreach \j in {-2.5,...,2.5}
		{
			
			
			\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
				\node[right,xshift=0.2cm,yshift=0.4cm] {};
				% Convert \j and \i to integers
				\pgfmathtruncatemacro{\intj}{\j}
				\pgfmathtruncatemacro{\inti}{\i}
				
				% Draw circles at the midpoints of each side
				\ifnum\intj=2
				\draw node[draw,circle,fill=gray] at (0,0.5) {};
				\else
				\draw node[draw,circle,fill=white] at (0,0.5) {};
				\fi
				
				\ifnum\inti=2
				\draw node[draw,circle,fill=gray] at (0.5,0) {};
				\else
				\draw node[draw,circle,fill=white] at (0.5,0) {};
				\fi
				
				\draw node[draw,circle,fill=white] at (0,-0.5) {};
				\draw node[draw,circle,fill=white] at (-0.5,0) {};
			\end{scope}
		}
	}
	
	\foreach \i in {-2,...,-2}
	{
		\draw[black, line width=1.5mm] (\i,-1) -- (\i,1.5);
		\node[draw, circle, fill=black] at (\i,-0.5) {};
		\node[draw, circle, fill=black] at (\i,0.5) {};
		
		\draw[blue!50, line width=1.5mm] (\i,1.5) -- (\i,2.5);
		\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,1.5) {};
		\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,2.5) {};
		
		
	}
	
	\foreach \j in {2,...,2}
	{
		
		\draw[blue!50, line width=1.5mm] (-2.5, \j) -- (-1.5, \j);
		
		
		\draw[black, line width=1.5mm] (-1.5, \j) -- (1, \j);
		\draw node[draw,circle,fill=black] at (-0.5,\j) {};
		\draw node[draw,circle,fill=black] at (0.5,\j) {};
		\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z},label=north:\textbf{$A_{\vec{v}}$}] at (-2.5,\j) {};
		\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z}] at (-1.5,\j) {};
		
	}
	
	
	\foreach \i in {1,...,1}
	{
		\draw[black, line width=1.5mm] (\i,-1) -- (\i,2);
		\node[draw, circle, fill=black] at (\i,-0.5) {};
		\node[draw, circle, fill=black] at (\i,0.5) {};
		\draw node[draw,circle,fill=black] at (\i,1.5) {};
		
	}
	
	\foreach \j in {-1,...,-1}
	{
		\draw[black, line width=1.5mm] (-2, \j) -- (1, \j);
		\draw node[draw,circle,fill=black] at (0.5,\j) {};
		\draw node[draw,circle,fill=black] at (-0.5,\j) {};
		\draw node[draw,circle,fill=black] at (-1.5,\j) {};
	}
	
	
\end{tikzpicture}
\end{center}

\caption{String of occupied edges closed on an operator $A_{\vec{v}} $.}
\label{fig:Aveigen}
\end{figure}
		
%In a more formal notation what we are stating is that:

%\begin{center}
%	$A_{\vec{v}} |\psi\rangle = +1 |\psi\rangle$. 
%\end{center}

If we consider only closed loops, we can identify different configurations having such characteristic. The illustrations in figure 1.6 show some examples of them.
Each of these loops, having such properties, is an eigenstate of all $A_{\vec{v}} $ since, no matter how we locally apply $A_{\vec{v}} $, it will always preserve the sign of the state. 

%drawings 4 types of loops


\begin{figure}
	
	\begin{center}
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {-1,...,-1}
			{
				\draw[black, line width=1.5mm] (\i,-1) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};	
				
			}
			
			\foreach \i in {1,...,1}
			{
				\draw[black, line width=1.5mm] (\i,-1) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};	
				
			}
			
			\foreach \j in {1,...,1}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (1,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, fill=black] at (0.5,\j) {};		
				
			}
			
			\foreach \j in {-1,...,-1}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (1,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, fill=black] at (0.5,\j) {};		
				
			}
			
			
		\end{tikzpicture}
		
	\end{center}
	
	\vspace{1cm} 
	
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};		
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			
		\end{tikzpicture}		
	\end{center}
	
	\vspace{1cm} 
	
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[black, line width=1.5mm] (-2,\j) -- (2,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, fill=black] at (0.5,\j) {};		
				\node[draw, circle, fill=black] at (-1.5,\j) {};
				\node[draw, circle, fill=black] at (1.5,\j) {};		
				
			}
			
			
		\end{tikzpicture}
	\end{center}
	
	\vspace{1cm} 
	
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};		
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[black, line width=1.5mm] (-2,\j) -- (2,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, fill=black] at (0.5,\j) {};		
				\node[draw, circle, fill=black] at (-1.5,\j) {};
				\node[draw, circle, fill=black] at (1.5,\j) {};		
				
			}
			
			
		\end{tikzpicture}		
	\end{center}
	
	\caption{Examples of closed loops yielding $+1$ eigenvalue for $A_{\vec{v}} $}
	\label{fig:Loops}
\end{figure}


Now we focus on constraint (1.2). We want to apply the plaquette operator $B_{\vec{p}} $ only to eigenstates of $A_{\vec{v}} $, which we have determined above. The illustration in figure 1.7 shows an example of how to do it in practice with one of the eigenstates of $A_{\vec{v}} $.
Notice that, after the transformation, we do always end up with a valid eigenstate of $A_{\vec{v}} $ but any such state cannot be an eigenstate of $B_{\vec{p}} $ by itself.

%drawings Bp applied to loops
\begin{figure}
	
	\begin{center}
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[red!80, line width=1.5mm] (\i,0) -- (\i,1);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (\i,0.5) {};
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[red!80, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (\i,0.5) {};
				
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[red!80, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (-0.5,\j) {};		
				
			}
			
			\foreach \j in {1,...,1}
			{
				\draw[red!80, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (-0.5,\j) {};	
				
			}
			
			
		\end{tikzpicture}
		
		
		
		\vspace{1cm} 
		
		
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,0.5) {};
				
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};		
				
			}
			
			\foreach \j in {1,...,1}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, black] at (-0.5,\j) {};	
				
			}
			
			
		\end{tikzpicture}	

	\end{center}

\caption{Examples of $B_{\vec{p}} $ to a closed loop.}
\label{fig:applyBp}
\end{figure}


Furthermore, any new configuration that we obtain through the application of the plaquette operator to eigenstates of $A_{\vec{v}} $ simply yields a permutation of the edges of the initial state, provided that the topological characteristics of the loop are preserved.

This means that if we firstly partition the eigenstates of $A_{\vec{v}} $ in the following fours classes: 

\begin{enumerate}
	\item class 0 : contains all closed loops as well as the state without loops; in other words, all of the closed loops can be continuously deformed into the state without loops.
	
	\item class 1 : contains loops that wind the torus all the way in the horizontal direction an odd number of times;
	
	\item class 2 : contains loops that wind the torus all the way in the vertical direction an odd number of times;
	
	\item class 3 : contains loops that wind the torus all the way in both directions an odd number of times. Notice also  that in class 3 the vertical loop must be taken on the dual lattice to yield a valid configuration.
	
\end{enumerate}

Then, applying a plaquette operator to any of the eigenstates belonging to one of the classes above must yield an eigenstate that lies in the same class. This is formally expressed by stating that the class is invariant under the action of the operator $B_{\vec{p}} $. 

\begin{proposition} (Invariance under $B_{\vec{p}} $) The four classes of eigenstates of $A_{\vec{v}} $ are invariant under the action of the $B_{\vec{p}} $ operators, for each $\vec{p} \in P$. 
\end{proposition}


%drawing loop chiuso ma unito da Bp
\begin{figure}
	
	\begin{center}	
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,1.5) {};
				
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};		
				
			}
			
			\foreach \j in {1,...,1}
			{
				\draw[black, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=black] at (-0.5,\j) {};
				\node[draw, circle, black] at (-0.5,\j) {};	
				
			}
			
			
		\end{tikzpicture}	
		
		\vspace{1cm} 
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
				\draw[red!80, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=red!80, label = center:\textbf{X}] at (\i,0.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
				
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\draw[red!80, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,1.5) {};
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (\i,0.5) {};
				
			}
			
			\foreach \j in {0,...,0}
			{
				\draw[red!80, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (-0.5,\j) {};		
				
			}
			
			\foreach \j in {1,...,1}
			{
				\draw[red!80, line width=1.5mm] (-1,\j) -- (0,\j);
				\node[draw, circle, fill=red!80,label = center:\textbf{X}] at (-0.5,\j) {};
				
				
			}
			
			
		\end{tikzpicture}	
		
		\vspace{1cm} 
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-2,-1.5,...,2}
			{
				\draw[dashed] (\i,-2) -- (\i,2);
			}
			\foreach \j in {-2,-1.5,...,2}
			{
				\draw[dashed] (-2,\j) -- (2,\j);
			}
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-2,-2) grid (2,2);
			\foreach \i in {-1.5,...,1.5}
			{
				\foreach \j in {-1.5,...,1.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=1
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=1
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {0,...,0}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
				\draw[black, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,0.5) {};		
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				\draw[black, line width=1.5mm] (\i,-2) -- (\i,0);
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\node[draw, circle, fill=black] at (\i,-0.5) {};
				
				\node[draw, circle, fill=black] at (\i,-1.5) {};
				\node[draw, circle, fill=black] at (\i,1.5) {};		
				
				
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (\i,1) -- (\i,2);
				\draw[black, line width=1.5mm] (\i,0) -- (\i,1);
				\node[draw, circle, fill=black] at (\i,1.5) {};
				\node[draw, circle, fill=black] at (\i,0.5) {};
				
			}
			
			
			
		\end{tikzpicture}	
		

	\end{center}

\caption{Apply $B_{\vec{p}} $ to a closed loop.}
\label{fig:Bpstrano}
\end{figure}

We do not provide a complete proof of the above result but illustrate various examples.
If we take the loop illustrated in figure 1.8 and close it by means of a plaquette operator as illustrated, we would be brought to believe that there indeed exist a way to apply the operator $B_{\vec{p}} $ such that we exit class 0 and land in class 1. Though, this is not possible. \newline
In fact, we can show the impossibility of the above action by defining two topological indeces to label the four classes of eigenstates. These indeces can assume values in $\mathbb{Z}_2=\{\overline{0},\overline{1} \}$, whose elements respectively represent the 'sets' of even and odd numbers. In our context such numbers identify the number of vertical and horizontal loops of a configuration intersecting the vertical and horizontal winding of the torus. Notice that the above mentioned intersections are meant to be computed by fixing two circles (figure 1.9): one horizontal circle and one vertical circle passing passing through the spins of the main lattice.

The above indeces can be expressed more clearly as follows: 

\begin{center}
	$n_x= (number \ of \ vertical \ intersections) \ \mathrm{mod} \ 2 \ \in \ {0,1} \ with \ the \ upper \ boundary$
\end{center}
\begin{center}
	$n_y= (number \ of \ horizontal \ intersections) \ \mathrm{mod} \ 2 \ \in \ {0,1} \ with \ the \ upper \ boundary$
\end{center}

%\begin{cases} 
%	0 \ \mathrm{mod} \ 2 \\
%	1 \ \mathrm{mod} \ 2  
%\end{cases}$ 

in order to create a correspondence with the actual definition of the torus over $(\mathbb{Z}$ $\times$ $\mathbb{Z})$. 
%We only change the representatives of the elements $\{\overline{0},\overline{1} \}$ in the intermediate step. \newline

We can then label the four classes as : $(\overline{0},\overline{0} )$, $(\overline{0},\overline{1} )$, $(\overline{1},\overline{0})$, $(\overline{1},\overline{1})$.\newline

For example, if we take again the configuration in figure 1.9, we have 1 vertical intersection and 1 horizontal intersection, therefore we are in the class 3 indexed by $n_x$ and $n_y=1$, which is labelled as $(\overline{1},\overline{1})$. This would holds for any odd number of vertical and horizintal intersections.


%drawing 1 vertical 1 hor
\begin{figure}
	\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-2,-1.5,...,2}
		{
			\draw[dashed] (\i,-2) -- (\i,2);
		}
		\foreach \j in {-2,-1.5,...,2}
		{
			\draw[dashed] (-2,\j) -- (2,\j);
		}
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-2,-2) grid (2,2);
		\foreach \i in {-1.5,...,1.5}
		{
			\foreach \j in {-1.5,...,1.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=1
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=1
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		\foreach \i in {0.5,...,0.5}
		{
			\draw[black!80, line width=1.5mm] (\i,-2) -- (\i,2);
			
		}
		
		\foreach \j in {0.5,...,0.5}
		{
			\draw[black!80, line width=1.5mm] (-2,\j) -- (2,\j);
			
			
		}
		
		
	\end{tikzpicture}		
\end{center}

\caption{One horizontal circle and one vertical circle passing passing through the spins of the dual lattice.} 
\label{fig:thirdkind}
\end{figure}


Similarly, if we go back to the configuration in figure 1.8, after the application of the operator $B_{\vec{p}} $ we do not land in class 1, but we remain in class 0; this is because we have an even number of horizontal intersections and an even number of vertical intersections, i.e. the indeces eual   $(\overline{0}, \overline{0})$.

Hence all the classes are $B_{\vec{p}} $-$invariant$ due to the topological properties of the torus. More formally, given $|\psi_1\rangle,...,|\psi_i\rangle,...,|\psi_n\rangle$ the eigenstates of $A_{\vec{v}}$, $\forall \vec{v} \in V$ all belonging to the same class, we can construct a state $|\psi\rangle$:

\begin{center}
	$|\psi\rangle$=$\frac{1}{\sqrt{n}}\sum_{j=1}^{n} |\psi_j\rangle$
\end{center} 

Then since we know that for every $\{ i \in 1 ... n \}$ $B_{\vec{p}} |\psi_i\rangle=+|\psi_j\rangle$ for some $j \in \{ 1 ... n\}$ we get:
%then if we apply $B_{\vec{p}} $ to the normalized state $|\psi\rangle$ we get:

\begin{center}
	$|\Xi\rangle= B_{\vec{p}}  \frac{1}{\sqrt{n}} \sum_{j=1}^{n} |\psi_i\rangle = \frac{1}{\sqrt{n}} \sum_{j=1}^{n} B_{\vec{p}} |\psi_i\rangle = \frac{1}{\sqrt{n}} \sum_{j=1}^{n} |\psi_J\rangle =|\Xi\rangle , \forall \vec{p} \in P$
\end{center}

because, $B_{\vec{p}} $ simply permutes all $|\psi_i\rangle$, thus we get back our initial state. This result leads to the following proposition:

\begin{proposition}(Eigenstates of $B_{\vec{p}} $) A completely symmetric superposition of all the eigenstates of $A_v$, all belonging to the same class, is an eigenstate of $B_{\vec{p}} $.
\end{proposition}

From Proposition 1.6 and Proposition 1.7, also naturally follows the degeneracy (and dimension) of the ground state manifold: \newline

\begin{proposition} (Degeneracy of the ground state) The degeneracy of the ground state manifold is $4$. 
\end{proposition}

\textit{Proof.}\newline
Because the four classes of eigenstates are $B_{\vec{p}} $-$invariant$, we can construct a valid ground state through the configurations belonging to one the four classes, as these configurations respect both constraint (1.1) and (1.2). 

\hfill $\square$
 
Now that we have characterized the ground state configurations of the toric code, we focus on studying its excited states. These states arise from perturbations or interactions within the system and offer valuable insights into the dynamic behavior of the toric code beyond its ground state equilibrium. While the ground state embodies the system's lowest energy configuration and serves as the foundation of its stability, the excited states provide an insight into the system's response to external influences. 
Through the systematic study of these excitations we discover some intrinsic features of the toric code that will serve us later to explain its fault-tolerant nature.


%-------------------------





















\newpage
\section{Excited States}
\label{sec:ES}

%We shall now examine the case of a square lattice with boundary conditions, i.e. the toric code. \newline

Taking into account the results of the previous chapters, we now proceed to describe, firstly, what are the excitations of the ground states and what is their exchange statistics. In general, the low-energy excitations of a quantum system, often referred to as quasiparticles, represent deviations from the system's ground state. These excitations are associated to elementary quantum particles that can be created or annihilated with relatively low energy. The properties of these quasiparticles, including their statistics, are crucial for gaining insights into the system's ground state degeneracy, topological properties and response to external perturbations. \newline
In the particular case of the toric code, such low-energy excitations can be created through the application of a string operator on the ground state (figure 1.10). Let us start by introducing some definitions that will be useful in the following.

\begin{definition}(Adjacent edges)
	We say that the edges  $e_1=$($v_1,v_1'$), $e_2=$($v_2,v_2'$) $\in E$ are adjacent if $e_1\neq e_2$ and $\{ \vec{v}_1, \vec{v'}_1\}$ $\cap $ $\{ \vec{v}_2, \vec{v'}_2\}$ $\neq$ $\emptyset$.
\end{definition}

\begin{definition}(Length of a string)
	We define the length of a strin as $\ell_\Sigma$=$\max \{ |(\vec{v'}_n-\vec{v}_1)_y|, |(\vec{v}_n-\vec{v'}_1)_y|, |(\vec{v'}_n-\vec{v}_1)_x|, |(\vec{v}_n-\vec{v'}_1)_x| \}$
\end{definition}

\begin{definition}(String $\Sigma$)
	A string $\Sigma$ consists of a set of numbered edges $\{e_1, \dots, e_i, \dots e_n\}$ where $e_i$ is adjacent to $e_{i+1}$ and such that the overall length of the string is equal to $\ell_\Sigma < N$.
\end{definition}

\begin{definition}(Endpoints of a string)
	Given a string $\ell$ we identify its endpoints with the initial vertex $\vec{v_1}$ and its final vertex $\vec{v_n'}$.
\end{definition}

\begin{definition}(Macroscopic loop)
	A macroscopic loop consists of a set of $\{e_1, \dots, e_n\}$ such that $e_1$=$e_n$ and $\ell_\Sigma \ge N$.
\end{definition}

\begin{definition}($S^x_\Sigma$ string operator)
	Given a string $\Sigma$, the string operator is given by $S_\Sigma^x = \prod_{j=1}^{n}\sigma_{e_j}$.
\end{definition}

\begin{definition}($S^z_\Sigma$ string operator)
	Given a string $\Sigma$, the string operator is given by $S_\Sigma^z = \prod_{j=1}^{n}\sigma_{e_j}$.
\end{definition}

The application of string operators creates quasi-particles at their endpoints. In particular we can get two distinct types of excitations (figure 1.10):

\begin{definition}(Electric charges)
	The pairs of particles generated by the application of a string operator $S^x_\Sigma$ on a ground state are called electric charges $\epsilon$.
\end{definition}

\begin{definition}(Magnetic vortices)
	The pairs of particles generated by the application of a string operator $S^z_\Sigma$ on a ground state are called magnetic vorteces $\mu$.
\end{definition}

These excitations can be transported on the lattice via the action of vertex and plaquette operators and interact with each other so characterizing the low energy spectrum.\newline
In order to understand this, we study the relationships between string operators and vertex/plaquette operators as we have defined them in  (see section 1.2).\newline

%picture
\begin{figure}
	
	\begin{center}
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {-2,...,-2}
			{
				\draw[red!30, line width=1.5mm] (\i,-1) -- (\i,-0.5);
				\draw[red!50, line width=1.5mm] (\i,-0.5) -- (\i,1.5);
				\draw[red!30, line width=1.5mm] (\i,1.5) -- (\i,2);
				\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=south:\textbf{\large \bf $\epsilon$}] at (\i,-0.5) {};
				\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (\i,0.5) {};
				\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=north:\textbf{\bf \large $\epsilon$}] at (\i,1.5) {};
				
			}
			
			\foreach \j in {-1.5,...,-1.5}
			{
				\draw[blue!30, line width=1.5mm] (0.5, \j) -- (1, \j);
				\draw[blue!50, line width=1.5mm] (1, \j) -- (2, \j);
				\draw[blue!30, line width=1.5mm] (2, \j) -- (2.5, \j);
				
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{$\sigma^z$},label=left:\textbf{\large \bf $\mu$}] at (1,\j) {};
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{$\sigma^z$},label=right:\textbf{\large \bf $\mu$}] at (2,\j) {};
				
			}
			
			
		\end{tikzpicture}
	\end{center}
	
	\caption{Graphical representation of $\epsilon$ and $\mu$ excitations on the ground state.}
	\label{fig:excitations}
\end{figure}





%\newpage
We can indeed prove that a string operator $S^x_\Sigma$ operator anticommutes with $A_{\vec{v}} $ for each one of its endpoints. 

\begin{proposition}(Anticommutation of $S^x_\Sigma$)
	Given a string $\Sigma$, the string operator $S^x_\Sigma$ anticommutes with $A_{\vec{v}} $, for any $\vec{v}$ $\in$($\vec{v_1},\vec{v_n'}$) where $\vec{v_1},\vec{v_n'}$ are the endpoints of the string $\Sigma$.
\end{proposition}

\textit{Proof.}\newline
Let $\vec{v}$ be one of the endpoints of $\Sigma$. We want to show that $A_{\vec{v}} S^x_\Sigma + S^x_\Sigma A_{\vec{v}}=0$. Knowing that for $\vec{v}$

\begin{center}
	$A_{\vec{v}} = \prod_{i=1}^{4} \sigma_i^z$ \\ 
	$S^x_\Sigma = \prod_{j=1}^{N} \sigma_j^x$
\end{center}

by substitution we obtain the following expression: 

\begin{equation}
	\space\prod_{i=1}^{4} \sigma_i^z \prod_{j=1}^{N} \sigma_j^x + \prod_{j=1}^{N} \sigma_j^x \prod_{i=1}^{4} \sigma_i^z = 0  
\end{equation}

remeber that only one $\sigma_i^z$ will overlaps with the endpoints of the string $S^x_\Sigma$; thus, only one $\sigma_i^z$ anticommutes with the endpoints of the string $S^x_\Sigma$. Knowing that Pauli matrices acting on the same edge anticommute

\begin{center}
	$\sigma_{v'}^x \sigma_{v'}^z = - \sigma_{v'}^z \sigma_v^x$ for $v=v'$ \\
	$\sigma_v^x \sigma_{v'}^z =  \sigma_{v'}^z \sigma_v^x$ for $v \neq v'$ 
\end{center}

if for simplicity we fix $N=2$ we can easily see that :

\begin{center}
	$(\sigma_1^z \sigma_2^z \sigma_3^z \sigma_4^z)(\sigma_1^x \sigma_2^x)  = - (\sigma_1^x \sigma_2^x)(\sigma_1^z \sigma_2^z \sigma_3^z \sigma_4^z) $ 
\end{center}

having supposed that, for example, the extremity $\sigma_1^x$ overlaps with the $\sigma_3^z$ edge part of the $A_{\vec{v}} $ operator (figure 1.11). This can then be easily generalized to $N$ Pauli operators. Finally, if we substitute such expression in $(1.3)$ we obtain that the overall equation is in fact equal to zero. \newline
This procedure should be iterated also for the other extremity of the string $S^x_\Sigma$ to show that the operator commutes with two $A_{\vec{v}} $ operators, one for each endpoint.

\hfill $\square$ 


\begin{figure}
	
	\begin{center}
		
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			\foreach \i in {-2,...,-2}
			{
				\draw[red!50, line width=1.5mm] (\i,-0.5) -- (\i,1.5);
				\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x_3$}] at (\i,-0.5) {};
				\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x_2$}] at (\i,0.5) {};
				
				\draw[blue!50, line width=1.5mm] (\i,1.5) -- (\i,2.5);
				\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z_3$}] at (\i,1.5) {};
				\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z_1$}] at (\i,2.5) {};
				
				
			}
			
			\foreach \j in {2,...,2}
			{
				
				\draw[blue!50, line width=1.5mm] (-2.5, \j) -- (-1.5, \j);
				
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{$\sigma^z_1$},label=north:\textbf{$A_{\vec{v}}$}] at (-2.5,\j) {};
				\draw node[draw,circle,fill=blue!50,label=center:\textbf{$\sigma^z_2$}] at (-1.5,\j) {};
				
			}
			
			\foreach \j in {-1,...,-1}
			{
				
				\draw[blue!50, line width=1.5mm] (-2.5, \j) -- (-1.5, \j);
				
			    \node[draw,circle,fill=blue!50,label=center:\textbf{$\sigma^z$},label=north:\textbf{$A_{\vec{v}}$}] at (-2.5,\j) {};
				\node[draw,circle,fill=blue!50,label=center:\textbf{$\sigma^z$}] at (-1.5,\j) {};
				
			}
			
			\foreach \i in {-2,...,-2}
			{
				
				\draw[blue!50, line width=1.5mm] (\i,-0.5) -- (\i,-1.5);
				\node[draw, circle, fill=blue!50, label=center:\textbf{$\sigma^z$}] at (\i,-1.5) {};
				\node[draw, circle, fill=blue!50, label=center:\textbf{$\sigma^z$}] at (\i,-0.5) {};
				
				
			}
			
			
		\end{tikzpicture}
	\end{center}
	
	\caption{String operator anticommutes with two $A_{\vec{v}}$ each.}
	\label{fig:Av&string}
\end{figure}


In the same way, we could prove that, if we take a string $S^z_\Sigma$ it anticommutes with one $B_{\vec{p}} $ for each one of its endpoints.

\begin{proposition}(Anticommutation of $S^z_\Sigma$)
	The $S^z_\Sigma$ operators anticommute with two $B_{\vec{p}}$, one for each endpoint $e_1$ and $e_n$ of the string $\Sigma$.
\end{proposition}

The effect of putting such strings on the ground states correspond to raising the associated energy of the ground states by 2. In fact, coherently with what said in {\cite{Her20}}, it is impossible to create unitary excitations on the ground states.

\begin{proposition}(Magnitude of the excitations)
	Acting with a string operator on the ground state corresponds to raising the associated energy of the ground states by 2.
\end{proposition}

\textit{Proof.} \newline
Recall that for a string operator, here we will choose $S^x_\Sigma$, both equations hold:

\begin{center}
	$\begin{cases} 
		A_{\vec{v}_1}S^x_\Sigma + S^x_\ell A_{\vec{v}_1}  =0 \\
		A_{\vec{v}_2} S^x_\Sigma + S^x_\ell A_{\vec{v}_2} =0
	\end{cases}$ 
\end{center}

If we apply the string operator to the ground state, taking into account anticommutativity stated above, we obtain that:

\begin{center}
	$\begin{cases}
		A_{\vec{v}_1} S^x_\Sigma |GS\rangle = - S^x A_{\vec{v}_1} |GS\rangle = - S^x_\Sigma |GS\rangle \\
		
		A_{\vec{v}_2} S^x_\Sigma |GS\rangle = - S^x A_{\vec{v}_2} |GS\rangle = - S^x_\Sigma |GS\rangle
	\end{cases}$ 
\end{center}

since $A_{\vec{v}_1}|GS\rangle = +1|GS\rangle$ and $A_{\vec{v}_2}|GS\rangle = +1|GS\rangle$.
Summing up term by term :

\begin{center}
	$\begin{cases}
		A_{\vec{v}_1} S^x_\Sigma |GS\rangle + A_{\vec{v}_2} S^x_\ell |GS\rangle = - 2 S^x_\Sigma A_{\vec{v}_1} |GS\rangle
	\end{cases}$ 
\end{center}

Thus, if the energy of the ground state is $-2N$ by acting with a string operator on  it we obtain a final energy equal to $-2N+2$.

\hfill $\square$ 

%Firstly, we study the individual statistics of electric charges and magnetic votices, then we argue their mutual statistics.\newline






\subsection{Fermionic and bosonic exchange statistics in 3D and 2D}
We give here a brief description of the statistics of fermions and bosons in three and two dimensions. \newline
Firstly, we introduce indistinguishable particles by means of their physical properties 

\begin{definition}(Indistinguishable particles)
	Indistinguishable particles in Quantum Mechanics are particles that share the same mass, electric charge and spin.
\end{definition}

However, we can characterize identical particles by means of their wavefunctions, which are mathematical functions that represent the probability amplitude of finding a particle at a certain position. 
In fact, in Quantum Mechanics, due to the uncertainty principle, we know that it is not possible to measure any two physical properties, such as position and momentum of a particle, together and with infinite precision. Indeed, this would correspond to the progressive spreading and overlap of the wavefunctions of the particles in the system, leading to indistinguishability.
Therefore, what we do is calculating a probabilistic location of the particles. As a consequence, in order to study the behaviour of the particles we look at the overall acquired phase of the wavefunction of the system of which they are part of. Observing such phase allows us to classify particles by assigning them bosonic or fermionic statistics, which correspond to symmetric or antisymmetic wavefunctions meaning that the system will acquire a phase corresponding to +1 or -1, respectively. As we will see, there also exist cases where we obtain mutual statistics that fall out of the bosonic or fermionic ones. By controlling the acquired phase of the wavefunction, we can deduce interference patterns between particles, which is important to perform quantum computations. \newline

If we take a system of indistinguishable particles in three dimensions as in \cite{Cor23}, if we exchange any two of them such that $i<j$ we can only obtain a phase $\phi=\pm \pi$ in the resulting wave function:  

\begin{center}	
	$P_{(i,j)}\psi(x_1, ..., x_i,x_j, ..., x_N)=e^{i\phi} \psi(x_1, ..., x_j,x_i, ..., x_N)=\pm \psi(x_1, ..., x_j,x_i, ..., x_N)$
\end{center}

where $P_{(i,j)}$ indicates the permutation operator that exchanges two particles according to the permutation group $\mathbb{P_N}$ that characterizes fermionic and bosonic statistics. 

\begin{definition}(Permutation operator)
	Given a set of $N$ objects an operator $P \in P_N$ acts as $(P \psi)(x_1,...,x_N)=\psi(x_{\pi(1)}, ..., x_{\pi(N)})$ with $\pi$ permutation of $N$ objects.
\end{definition}

The permutation group $\mathbb{P}_N$ is defined as the set of all possible permutations involving $N$ objects. Within this group, the operation of group multiplication (exchange) corresponds to the sequential application of permutations, and the group inverse involves the inverse of the permutation. Here, executing a permutation twice on two objects results in the initial configuration of the system.
Consequently, the Hilbert space of a quantum system of indistinguishable particles must be a realization of a one-dimensional representation of the permutation group; there exist only two such representation (inequivalent and irreducible), corresponding to bosons or fermions.
To visualize the behaviour described above, consider the case where the relative coordinate of the particles is constrained to move on a sphere. Closed paths emerge when particles return to their original positions (no exchange) or reach the antipodal point (exchange). In fact, we will have three distinct types of paths (figure 1.12): 

%picture
\begin{center}
	\item[(a)]: closed loops without exchange; they can disappear if reduced to a point, implying that the wave-function cannot acquire any phase; 
	
	\item[(b)] : involve a single exchange; they connect two fixed points on the sphere, making it impossible to erase them. Consequently, this types of exchanges introduce a phase in the wave-function;
	
	\item[(c)] : closed loops with two exchanges, as in case 1; as a result, also in this case the wavefunction does not acquire any additional phase.
\end{center}

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{"../Thesis/Immagine 2024-02-22 113658"}
	\caption{{ Possible exchanges of two particles in 3D. From: \cite{Rao16}.}}
	\label{fig:immagine-2024-02-22-113658}
\end{figure}

Overall, we only have two classes of paths: those that do not involve any exchange as in class (a) and (c), and those that are characterized by an exchange as in class (b). 
Since exchanging the particles twice leads again to no exchange, we must have $e^{2i \phi} = 1$. This means that $\phi$ can either be 0 or $\pi$ giving rise to bosonic and fermionic statistics, respectively. 

%\begin{enumerate}
	%\item $\phi = 0$: this case leads to the constructive interference of the exchange paths. The resulting particles are known as bosons, and their behavior is characterized by this specific phase condition;
	
	%\item $\phi = \pi$: this case results in destructive interference between the exchange paths. The particles corresponding to this scenario are referred to as fermions, and their behavior is governed by this particular phase condition.
%\end{enumerate}

In contrast to what stated above, take a system of $N$ indistinguishable particles in two dimensions, if we exchange any two of them such that $i<j$ we can obtain any phase $\phi$ in the resulting wave function, based on the number of exchanges:  

\begin{center}	
	$R_{(i,j)}\psi(x_1, ..., x_i,x_j, ..., x_N)=R_{(i,j)} e^{i\phi} \psi(x_1, ..., x_j,x_i, ..., x_N)= R_{(i,j)} e^{i2\phi} \psi(x_1, ..., x_i,x_j, ..., x_N)=R_{(i,j)} e^{i3\phi} \psi(x_1, ..., x_j,x_i, ..., x_N)= ... \ \newline
	... = e^{in\phi} \psi(x_1, ..., x_i,x_j, ..., x_N)$
\end{center}

where $R$ represents the braiding operator, which corresponds to the exchange operator for particles in two dimensions. The resulting statistics is characterized according to the braiding group  $\mathbb{B_N}$. We can visualise the process of moving (or exchanging) particles as paths in spacetime with time being the vertical axis and space being the horizontal axis (figure 1.14). The particles can circle around each other and form closed paths by coming back to their original positions {\cite{Wil91}}. For further details see {\cite{Rao16, Wil91}}.
To visualize the above behaviour, consider moving particles on a circle. This time several possible paths are possible, in particular closed paths. In fact, if we classify again the possible paths as we did before, this time we obtain these three classes (figure 1.13):

\begin{center}
	\item[(a)] : those that can be shrunk into a point;

	\item[(b)] : those that cannot be contracted into a point as the endpoints remain fixed;

	\item[(c)] : also this kind of paths cannot be shrunk into a point since they wind all  the way around the circle. Notice that in three dimensions the path corresponding to two exchanges is equivalent to no exchange at all, while this is not possible in two dimensions. This will be crucial for the existence of intermidiate statistics that exist only in 2D (section 1.5).
\end{center}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{"../Thesis/Immagine 2024-02-22 112906"}
	\caption{ { Possible exchanges of two particles in 2D \cite{Rao16}. We denote diametrically opposite points on the circle (x, empty end black point) to indicate the starting and ending points of a half- exchange of particles along with the three possible paths denote as A,B and C. Case A represents a contractible string, case B represents a non-contractible string obtained through a half-exchange happening between two diametrically opposite points and case C represents a non-contractible string obtained by means of a double half-exchange.}}
	\label{fig:immagine-2024-02-22-112906}
\end{figure}

Overall, for $ \phi = 0, \pi$ we would obtain the usual bosons and fermions statistics, but since in general, $e^{in\phi} \neq \pm 1$ for any $n$ ($n$ exchanges never yield the identity), $\phi$ can be anything so any statistic is possible in two dimensions.
Such diverse statistics in two dimensions are called fractional or \textit{anyonic} (see section 1.5).\newline


\begin{figure}
	\centering
	\includegraphics[width=0.5\linewidth]{"../Thesis/Immagine 2024-02-23 134521"}
	\caption{{ Identical particles exchange position twice as
			they travel in three dimensions (no exchange). Particle a and b move along a closed path in two dimesions (non contractible) \cite{Wil91}}.}
	\label{fig:immagine-2024-02-23-134521}
\end{figure}
%----

%\newpage
We can now analyze the statistics of $\epsilon$-particles in the context of the ground state of the toric code. If we consider the action of a string operator $S^z_e$ on any ground state $|GS\rangle$, it creates two $\epsilon$-particles of the vertices adjacent to the edge $e$, as shown in figure 1.15. As we are going to see, a string operator implements the exchange of these two excitations. In fact, as illustrated in figure 1.15, the exchange of these particles becomes possible by applying the string operator in such a way that it moves the excitations around the lattice until they reach the final configuration (c) shown in figure 1.15. However, due to the commutation of all $\sigma^x$ with each other, after the application of a closed loop of $\sigma^x$ (last step in figure 1.15), there is no overall acquired phase. Consequently, the $\epsilon$-excitations obey bosonic statistics {\cite{Rao16, Her20}}. A similar argument can be carried out for the $\mu$-excitations, proving that they behave as bosons as well. 


%picture
\begin{figure}
\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-2,-1.5,...,2}
		{
			\draw[dashed] (\i,-2) -- (\i,2);
		}
		\foreach \j in {-2,-1.5,...,2}
		{
			\draw[dashed] (-2,\j) -- (2,\j);
		}
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-2,-2) grid (2,2);
		\foreach \i in {-1.5,...,1.5}
		{
			\foreach \j in {-1.5,...,1.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=1
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=1
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		
		
		\foreach \j in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (-0.5, \j);
			%\draw node[label=north:\textbf{ \large $e_1$}] at (-1,\j) {};
			\draw[red!50, line width=1.5mm] (-0.5, \j) -- (0, \j);
			%\draw node[label=north:\textbf{ \large $e_2$}] at (0,\j) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=left:\textbf{ \large $\epsilon_1$},label=right:\textbf{ \large $\epsilon_2$}] at (-0.5,1) {};
			
		}
		
	\end{tikzpicture}
\end{center}

\vspace*{1cm}

\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-2,-1.5,...,2}
		{
			\draw[dashed] (\i,-2) -- (\i,2);
		}
		\foreach \j in {-2,-1.5,...,2}
		{
			\draw[dashed] (-2,\j) -- (2,\j);
		}
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-2,-2) grid (2,2);
		\foreach \i in {-1.5,...,1.5}
		{
			\foreach \j in {-1.5,...,1.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=1
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=1
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		
		
		\foreach \j in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (-0, \j);
			\draw node[label=center:\textbf{\large $\epsilon_2$}] at (0,\j) {};
			%\draw[red!50, line width=1.5mm] (-0.5, \j) -- (0, \j);
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,1) {};
			
		}
		
		\foreach \i in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,1) -- (\i,-1);
			%\draw node[label=north:\textbf{e1}] at (\i,0) {};
			%\draw[blue!50, line width=1.5mm] (\i,0) -- (\i,0);
			
			\node[draw, circle, fill=red!50,,label=center:\textbf{$\sigma^x$}] at (-1,0.5) {};
			\node[draw, circle, fill=red!50,,label=center:\textbf{$\sigma^x$}] at (-1,-0.5) {};
			
		}
		
		\foreach \j in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (1, \j);
			
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (0.5,-1) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (1,-0.5) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,-1) {};
			
		}
		
		\foreach \i in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,-0.4) -- (\i,0.4);
			\draw node[label=north:\textbf{\large $	\epsilon_1$}] at (\i,0.5) {};
			%\draw[blue!50, line width=1.5mm] (\i,0) -- (\i,0);
			\draw[red!50, line width=1.5mm] (\i,-1) -- (\i,-0.6);
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (1,0.5) {};
			\draw[red!50, line width=1.5mm] (\i,0.3) -- (\i,1);
			
		}
		
		
		
	\end{tikzpicture}
\end{center}

\vspace*{1cm}

\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-2,-1.5,...,2}
		{
			\draw[dashed] (\i,-2) -- (\i,2);
		}
		\foreach \j in {-2,-1.5,...,2}
		{
			\draw[dashed] (-2,\j) -- (2,\j);
		}
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-2,-2) grid (2,2);
		\foreach \i in {-1.5,...,1.5}
		{
			\foreach \j in {-1.5,...,1.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=1
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=1
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		
		
		\foreach \j in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (0, \j) -- (1, \j);
			\draw node[label=center:\textbf{\large $\epsilon_1$}] at (0,\j) {};
			\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (0.5,\j) {};
			%\draw node[label=center:\textbf{e2}] at (0,\j) {};
			%\draw[red!50, line width=1.5mm] (-0.5, \j) -- (0, \j);
			
			%\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,1) {};
			
		}
		
		\foreach \i in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,-1) -- (\i,0.5);
			\draw[red!50, line width=1.5mm] (\i,0.7) -- (\i,1);
			\draw node[label=center:\textbf{\large $\epsilon_2$}] at (\i,1) {};
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-1,0.5) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-1,-0.5) {};
			
		}
		
		\foreach \j in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (1, \j);
			
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (0.5,-1) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (1,-0.5) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,-1) {};
			
		}
		
		\foreach \i in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,-0.4) -- (\i,0.4);
			\draw[red!50, line width=1.5mm] (\i,-1) -- (\i,-0.6);
			\draw[red!50, line width=1.5mm] (\i,0.6) -- (\i,1);
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (1,0.5) {};
			
		}
		
		
		
	\end{tikzpicture}
\end{center}

\vspace*{1cm}

\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-2,-1.5,...,2}
		{
			\draw[dashed] (\i,-2) -- (\i,2);
		}
		\foreach \j in {-2,-1.5,...,2}
		{
			\draw[dashed] (-2,\j) -- (2,\j);
		}
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-2,-2) grid (2,2);
		\foreach \i in {-1.5,...,1.5}
		{
			\foreach \j in {-1.5,...,1.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=1
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=1
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		
		
		\foreach \j in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (-0.5, \j);
			%\draw node[label=north:\textbf{ \large $e_1$}] at (-1,\j) {};
			\draw[red!50, line width=1.5mm] (-0.5, \j) -- (0, \j);
			%\draw node[label=north:\textbf{ \large $e_2$}] at (0,\j) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=left:\textbf{ \large $\epsilon_2$},label=right:\textbf{ \large $\epsilon_1$}] at (-0.5,1) {};
			
		}
		
	\end{tikzpicture}
\end{center}


\caption{In the first picture we show the creation of a pair of $\epsilon$-excitations on the ground state by means of $\sigma^x$ operator. In the following pictures we move around the excitations using a string operator until we reach the configuration in the third picture. In the last passage we apply a closed loop of $\sigma^x$ in order to go back to the first kind of configuration {\cite{Rao16}}. }
\label{fig:base}
\end{figure}

%--------------------------

























\newpage
\section{Anyonic Excitations}
\label{sec:AE}

Let us examine now the mutual statistics between the $\epsilon$ and $\mu$ particles by means of an example. \cite{Rao16}. Initially, we generate pairs of excitations at distinct chosen sites by applying two $S^x_{\ell}$ and $S^z_{\ell}$ operators as shown in figure 1.16. There, we separate the excitations using string operators and we move an $\epsilon$-particle around an $\mu$-particle, as depicted in figure 1.17. Notice that there is a site where $\sigma^z$ must cross a $\sigma^x$ operator, resulting in an anticommutation and thus introducing a minus sign {\cite{Kit02}}.
The closed loop can be eliminated, leading to the following transformation:

\begin{center}
	$\sigma_i^z\sigma_i^x|\psi\rangle = - \sigma_i^x\sigma_i^z|\psi\rangle$
\end{center}

if we denote the exchange operator as {\it the braiding operator} $R$ (see \cite{Rao16}) then, according to the discussion in Section 1.4.1, we have that

\begin{center}
	$R^2\psi(\epsilon,\mu) = - \psi(\epsilon,\mu)$
\end{center}

since we are going all the way around the particle, wehave performed two exchanges in 2D. Then, we find out that:

\begin{center}
	$R^2 = - 1 \rightarrow ( e^{-\frac{i\pi}{2}})^2 = - 1  \rightarrow R = e^{-\frac{i\pi}{2}} = \pm i $
\end{center}

which cannot be described by the usual bosonic/fermionic statistics. Thus we can say that the low-energy excitations of the ground state exhibit mutual anyonic statistics \cite{Rao01,Kha98}.
%(recalling the fact that we can obtain \textit{any} statistics). {\cite{Rao16, Kit02, Pre04}}.\newline


%picture
\begin{figure}
	\begin{center}
		\begin{tikzpicture}
			% Draw dashed lines
			\foreach \i in {-3,-2.5,...,3}
			{
				\draw[dashed] (\i,-3) -- (\i,3);
			}
			\foreach \j in {-3,-2.5,...,3}
			{
				\draw[dashed] (-3,\j) -- (3,\j);
			}
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\else
						\draw node[draw,circle,fill=white] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\else
						\draw node[draw,circle,fill=white] at (0.5,0) {};
						\fi
						
						\draw node[draw,circle,fill=white] at (0,-0.5) {};
						\draw node[draw,circle,fill=white] at (-0.5,0) {};
					\end{scope}
				}
			}
			
			
			
			
			\foreach \j in {1,...,1}
			{
				
				\draw[red!50, line width=1.5mm] (-2, \j) -- (1, \j);
				%\draw node[] at (0,\j) {};
				\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=right:\textbf{\large $\epsilon$}] at (0.5,\j) {};
				\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,\j) {};
				\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=left:\textbf{\large $\epsilon$}] at (-1.5,\j) {};
				
			}
			
			
			\foreach \j in {-0.5,...,-0.5}
			{
				
				\draw[blue!50, line width=1.5mm] (-2.5, \j) -- (0.5, \j);
				
				
				\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z$},label=left:\textbf{\large $\mu$}] at (-2,\j) {};
				\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z$},label=right:\textbf{\large $\mu$}] at (0,\j) {};
				\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z$}] at (-1,\j) {};
				
			}
			
			
		\end{tikzpicture}
	\end{center}
	
	
	\caption{Creation of the $\epsilon$-excitations and $\mu$-excitations.}
	\label{fig:anyons1}
\end{figure}

\begin{figure}
\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-3,-2.5,...,3}
		{
			\draw[dashed] (\i,-3) -- (\i,3);
		}
		\foreach \j in {-3,-2.5,...,3}
		{
			\draw[dashed] (-3,\j) -- (3,\j);
		}
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-3,-3) grid (3,3);
		\foreach \i in {-2.5,...,2.5}
		{
			\foreach \j in {-2.5,...,2.5}
			{
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=2
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=2
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		
		
		
		\foreach \j in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (-2, \j) -- (1, \j);
			%\draw node[] at (0,\j) {};
			\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (0.5,\j) {};
			\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,\j) {};
			\draw node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$},label=left:\textbf{\large $\epsilon$}] at (-1.5,\j) {};
			
		}
		
		\foreach \i in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,-1) -- (\i,1);
			\draw node[label=center:\textbf{\large $\epsilon$}] at (\i,1) {};
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-1,0.5) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-1,-0.5) {};
			
		}
		
		\foreach \j in {-1,...,-1}
		{
			
			\draw[red!50, line width=1.5mm] (-1, \j) -- (1, \j);
			
			
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (0.5,-1) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (1,-0.5) {};
			\node[draw, circle, fill=red!50,label=center:\textbf{$\sigma^x$}] at (-0.5,-1) {};
			
		}
		
		\foreach \i in {1,...,1}
		{
			
			\draw[red!50, line width=1.5mm] (\i,-0.4) -- (\i,0.4);
			\draw[red!50, line width=1.5mm] (\i,-1) -- (\i,-0.6);
			\draw[red!50, line width=1.5mm] (\i,0.6) -- (\i,1);
			
			\node[draw, circle, fill=red!50,,label=center:\textbf{$\sigma^x$}] at (1,0.5) {};
			
		}
		
		\foreach \j in {-0.5,...,-0.5}
		{
			
			\draw[blue!50, line width=1.5mm] (-2.5, \j) -- (0.5, \j);
			
			
			\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z$},label=left:\textbf{\large $\mu$}] at (-2,\j) {};
			\node[draw, circle, fill=blue!50,label=center:\textbf{$\sigma^z$},label=right:\textbf{\large $\mu$}] at (0,\j) {};
			\node[draw, circle, fill=purple!70,label=center:\textbf{$\pm$}] at (-1,\j) {};
			
		}
		
		
	\end{tikzpicture}
\end{center}


\caption{Creation of an anyonic excitation by braiding of $\epsilon$ and $\mu$ pairs of particles. Here we loop the $\epsilon$-excitation around an $\mu$-excitation. The red loop can be removed with the result that the ground state acquires a nontrivial phase.}
\label{fig:anyons}
\end{figure}



%-------------------------------









\chapter{Coding on the Toric Code}
\label{ch:chapter_two}

\section{Classical Error Correction}
\label{sec:CER}

In classical computing the most elementary unit of information is the {\it bit}. A bit stores binary information, which can either assume value 1 or 0. When we transmit information in the classical world, we immagine to make strings of bits travel through a channel similar to the one depicted below in figure 2.1. During the transmission a bit can change its value either going from 1 to 0 or viceversa, this event is called {\it bit-flip} and it tells us that an error has occured in the transmission. A bit-flip can occur independently on each bit with a certain probability that we will denote in general as $p$: mathematically, this translates to the assumption that errors, i.e. bit-flips,  are assumed to be independently identically distributed on all the bits with the same probability $p$. In such a case we say that errors are i.i.d. with probability $p$.\newline
The noisy channel described in picture 2.1 is one of the easiest error models also known as the $\textit{Binary Symmetric Channel}$. An error model, in the context of information theory and communication, is a mathematical or conceptual representation of how errors can occur during the transmission of information. It describes the types of errors that can happen, the probabilities associated to each type of error and the conditions under which these errors occur. \newline

%image
\begin{figure}
	\centering
	\includegraphics[width=0.5\linewidth]{../Thesis/324193_2_En_1_Fig3_HTML}
	\caption{{ Binary symmetric channel. From: \cite{Cha06}}}
	\label{fig:3241932en1fig3html}
\end{figure}


\newpage
In order to protect information what we do is introduce redundancy, which allows us to detect errors and correct them. Redundacy means duplicating bits of information before sending them through a channel. We say that we encode logical bits into {\it strings of bits} (physical bits). For example: the bit 0 can be encoded into the pair of bits 00 and 1 into 11. This is useful to detect errors because in this way, whenever a bit changes we know that a single error has occured since the pairs 10 and 01 should never occur. Formally speaking, we have introduced a {\it parity}: the strings 00 and 11 have an {\it even} parity while 10 and 01 have an {\it odd} parity. Whenever we receive a string, we perform {\it parity-check} and signal an error whenever we get odd parity. We will call the values obtained through the parity-check procedure {\it error syndromes}.\newline

In order to also be able to correct errors, the redundancy above is not enough since we would not be able to decide a criterion to correct the corrupted information. Thus, we introduce a third redundant bit and generate the {\it three repetition code}; in this way, when we decode information at the destination, we can apply what is called {\it majority voting}. Majority voting decodes into 1 those triplets that have most bits set to 1 and decodes as 0 the ones that have most bits set to 0. Though, as soon as two bit-flips happen, majiority voting stops working. In fact, the state 000 with two errors (110) would be associated to 111 and vice-versa. Therefore we will need other tools to decode information correctly. In fact, in the case of the three repetition code, in order to perform a parity-check we look at two 'error bits' for each parity in the error syndrome, which could still yield the same error syndrome for two different bit-flip errors scenarios (figure 2.2). Though, if we can assign a fixed iid error probability of $p<\frac{1}{2}$ for each bit, we will always end up choosing to decode the codeword with less errors. This method does not erase the possibility of getting decoding mistakes but significantly decreases them \cite{Kas19}.\newline


\begin{figure}
	\centering
	\includegraphics[width=0.5\linewidth]{"../Thesis/Immagine 2024-02-26 133707"}
	\caption{{ Example of error syndrome associated to a transmitted codeword of length 7. We have two equal error syndromes despite having two different codewords. Each '+' or '-' represents the parity of the bits acting as parents \cite{Kas19}}}
	\label{fig:immagine-2024-02-26-133707}
\end{figure}

The above redundant code is actually an example of what is called a {\it linear code}.
We can in fact reframe all of the above in terms of linear algebra. To do so we define what is called the generator matrix  \textbf{G} as given in \cite{Cha06,Kas19}, which is the operator that we use to introduce redundancy. 

\begin{definition}(Generator matrix)
	A linear code encoding k-bit messages into an m-bit codespace \textbf{C} is specified by an m $\times$ k matrix {\bf G}.
\end{definition}

The matrix \textbf{G} encodes the original information into { codewords}. For example, if we have a single bit to be encoded in a three bit codeword we can do the following: 

\begin{center}
	\textbf{G} = $[1 \ 1 \ 1]^{T}$,  
\end{center}
\begin{center}
	a = $[i]$, where i = 0,1 ,
\end{center}
\begin{center}
	$[1 \ 1 \ 1]^{T}$ $[0]$ = $[0 \ 0 \ 0]^{T}$.
\end{center}

A linear code encoding k-bit messages into an m-bit codespace \textbf{C} is specified by an m $\times$ k generator matrix {\bf G} is an [m, k] code.\newline

The { generator matrix} is used to encode information before sending it through a channel but we have also said that a realistic channel is noisy so it can modify the codewords we send. Thus, we also need to define an operator to specify how an error occurs and how to detect it. 

\begin{definition}(Noise operator)
	We denote a noise operator as $\textbf{N}_j \in \mathcal{N}$ where $j$ denotes the element that will be modified by $\textbf{N}_j$ in the original codeword and $\mathcal{N}$  represents the set of all possible error operators that could happen on the codeword. 
\end{definition} 

Overall, the codeword is changed by the noise operator into the correspondig codeword $c' =c + \textbf{n}_j$ where $\textbf{n}_j$ is an m $\times$ 1 vector having a 1 at the j-th row and zeros elsewhere; notice that, since we work with bits, addition is always performed modulo 2.\newline
Having defined all of the above we can come to parity-check performed after transmission.

\begin{definition}(Parity-check matrix)
	Given an m-bit codespace and a k-bit encoding, we define a parity check matrix as a matrix denoted by $\textbf{H}$ having size $(m - k)\times m $ and such that the code {\bf C} is the kernel of the parity-check matrix. 
\end{definition}

To check parity we can simply act with {\bf H} on the received codeword: 

\begin{center}
	\textbf{H}c = 0  
\end{center}

for any valid codeword. This exactly means that the code {\bf C} is the kernel of the parity-check matrix.\newline
Instead, for any corrupted codeword the computation yields:

\begin{center}
	$\textbf{H}c'$ = $\textbf{H} ( c + \textbf{n}_j )$ = $0 + \textbf{H} n_j $  = $\textbf{H}n_j $ 
\end{center}

which is the error syndrome. As anticipated, the error syndrome serves as an indicator of errors within a coding and decoding system. In the absence of errors, the error syndrome is represented as 0. This indicates a clean transmission. Conversely, in the case of a single error, the error syndrome is denoted as {\bf H}$n_j$, providing information about the specific bit j within the codeword where the error has taken place. Consequently, the corrupted codeword can be successfully decoded by correcting the jth bit. However, as already mentioned, when two errors $n_i$ and $n_j$ are present, the error syndrome becomes {\bf H}($n_i$ + $n_j$). In this case error correction becomes more difficult because there could be a type of error $n_q = n_i + n_j$ that makes error detection ambiguous, as we could correct the q-th bit instead of the j-th bit. Overall, it is possible to have multiple error combinations leading to the same syndrome. To prevent ambiguity, it is essential to verify that any additional error $n_q$ does not satisfy the condition $n_q = n_i + n_j$. If there are no such instances where $n_q$ equals $ n_i + n_j$, the decoding process can proceed with confidence. However, if such instances are detected, then ambiguity arises. One possible approach is to reject the codeword, prompting a request for retransmission from the sender. Alternatively, refining the encoding/decoding scheme may be considered. \newline

Because of the ambiguity that can arise in error correction it is essential to discuss formally the detectability and correctability of errors according to linear codes formalism given in \cite{Cha06} and discussed above.
We have mentioned how a codeword can be rejected if corrupted and how a receiver can ask to resend information. The efficacy of the encoding/decoding scheme is evaluated based on its ability to either maintain the integrity of information or detect errors caused by each noise operator. Therefore, we can state that a code successfully detects a noise operator $\textbf{N}$ if, for every codeword c within the code, the outcome is either $\textbf{N}$c = c or $\textbf{N}$c does not belong to the code $\textbf{C}$.

\begin{theorem}(Error detection)
	$\textbf{N}$ is detectable by a code if and only if for each $c_m \neq c_n$ in the code, $\textbf{N}c_n \neq c_m $.
\end{theorem} 

On the other hand, error correction involves an active process where the decoder does not only identifies errors but also corrects them. 
In the context of a code $\textbf{C}$ and a set of error operators $\textbf{N}$, the primary goal is to establish the presence of a decoding procedure capable of correcting errors introduced by $\textbf{N}$. 
Assuming the existence of distinct codewords $c_m$ and $c_n$ within the code, and for specific set of noise operators $\textbf{N}$, there could be situations such that if we apply $\textbf{N}_i$ to the codeword $c_m$ and the error operator $\textbf{N}_j$ to the codeword $c_n$ we end up in the same final state $c_q$. In such cases the challenge lies in determining whether the original codeword was $c_m$ or $c_n$. Thus, the error is unidentified meaning that it occurs in the set of error operators $\textbf{N}$ but we do not know which specific error operator caused it. In other words, given the state $c_q$, we cannot say which codeword was initially sent due to the ambiguity in identifying the specific error that occurred.

\begin{theorem}(Error correction)
	The set $\textbf{N}$ of errors is correctable if and only if for all $c_m \neq c_n$ in the code and for all $i, j \in \textbf{N}$, it is true that $\textbf{N}_ic_m$ $\neq$ $\textbf{N}_jc_n$. 
\end{theorem} 

Thanks to linear codes, we gain insights into the two essential steps of error recovery: error detection and error correction, which allows us to assess the efficacy of the code in its entirety. For further details see \cite{Kas19}. Moreover, in order to evaluate the robustness of a given code we can define the notion of {\it distance of a code} :


\begin{definition}(Hamming distance)
	Given two codewords, $c_m$ and $c_n$, the Hamming distance $d(c_m; c_n)$ is the minimum number of bits that must be flipped in order to transform $c_m$ into $c_n$.
\end{definition}


\begin{definition}(Distance of a code)
	The distance of a code {\bf C } is the minimal Hamming distance between any two distinct codewords $c_m$ and $c_n$ having $m \neq n$.
\end{definition}
	
To conclude, linear codes' representation plays a crucial role in studying encoding/decoding procedures along with their performance, offering an effective framework also to be used for the quantum world as well.

%-------------------------------------------









\newpage
\section{Quantum error correction (QEC)}
\label{sec:QEC}

Due to the no-cloning theorem, which states that  it is impossible to perfectly clone an arbitrary quantum state using quantum operations, one might be brought to think that error correction cannot be performed in the quantum setting.

\begin{theorem}(No cloning theorem)
	There is no unitary operator $U$ acting on the composite Hilbert space $\mathscr{H} \otimes \mathscr{H}$ such that for any $|\psi\rangle \in \mathscr{H}$:
	
	\begin{center}
		$U(|\psi\rangle\otimes|0\rangle) = |\psi\rangle \otimes |\psi\rangle$
	\end{center}
	
	where $|0\rangle$ is a reference state.
\end{theorem}

We will see that this problem can be solved, despite the two main issues that arise in quantum systems \cite{Cha06}.: 

\begin{enumerate}
	\item No cloning limitation: the attempt to implement a repetition code in the quantum setting by duplicating a quantum state multiple times violates the no-cloning theorem, which prevents the exact replication of a quantum state;
	
	\item Information loss through measurement: in contrast to classical error-correction, the act of measuring a quantum state typically results in the loss of quantum information contained in that state, as a consequence, the recovery of the original quantum information becomes impossible after a measurement.
\end{enumerate}

In the context of quantum computation, classical bits are replaced by quantum bits or qubits, which are represented by a two-level quantum system. More precisely, a qubit lives in an Hilbert space of dimension 2. A common physical realization of qubits involves spin-$\frac{1}{2}$ particles, such as electrons. The quantum state space of a qubit is spanned by two orthogonal basis vectors, conventionally denoted as $ |0 \rangle$ and $ |1 \rangle$, corresponding to the classical binary states 0 and 1. Mathematically, any qubit state 
$ |\psi \rangle$ can be expressed as a superposition of these states as:


\begin{center}
	$\alpha |0 \rangle$ + $\beta$ $|1 \rangle$ =  $[ \ \alpha \ \ \beta \ ]^T $
\end{center}

where $\alpha$ and $\beta$ are complex numbers and satisfy the normalization condition $|\alpha|^2$ + $|\beta|^2$ = 1. \newline
When it comes to qubits, computations are performed through operators, which are the quantum logical gates. Each quantum gate corresponds to a unitary operator, which is a linear transformation that preserves the norm of vectors (in this case, quantum states) and is represented by a unitary square matrix. These gates can perform various operations such as changing the phase of a qubit (phase-shift), performing logical operations like NOT(bit-flip), AND, or OR and more. In particular, a phase-shift error on a qubit alters the phase factor in the qubit's superposition state. \newline
We shall now discuss the quantum analog of the classical error correction theory \cite{Cha06}. \newline
Similarly to what we did with repetition codes, we can represent the bit-flip error (generally called {\it noise}) for qubits thrugh the gate $X$ and associate to it a proability $p$. \newline
Then, we can introduce redundancy, firstly by mapping the physical basis of qubits to their respective logical counterparts in the following way \cite{Nie06}:

\begin{center}
	$\alpha |0 \rangle$ + $\beta$ $|1 \rangle$ $\rightarrow$ $\alpha |000 \rangle$ + $\beta$ $|111 \rangle$
\end{center}

where we have encoded the basis vector as:

\begin{center}
	$|0 \rangle$ $\rightarrow$ $|0 \rangle_L$ $\equiv$ $|000 \rangle$   \\
	$|1 \rangle$ $\rightarrow$ $|1 \rangle_L$ $\equiv$ $|111 \rangle$
\end{center}

\begin{center}
	$|0\rangle_L = |0\rangle \otimes |0\rangle \otimes |0\rangle = |000\rangle$ \\
	$|1\rangle_L = |1\rangle \otimes |1\rangle \otimes |1\rangle = |111\rangle$
\end{center}

where L stands for {\it logical qubit} 
%and where we have encoded a quantum bit by means of the tensor product of three spins each being an eigenstate of the Pauli matrix $\sigma^z$ acting on each local Hilbert space: 

If we imagine to send all of the three bits one at a time through a channel and suppose that one or fewer qubits are flipped; we can define a simple quantum error correction scheme by means of detection and analysis of error syndromes, given by projector operators \cite{Nie06}:

\begin{enumerate}
	\item  $P_0$ = $|000 \rangle \langle 000|$ + $|111 \rangle \langle 111|$, which corresponds to the projector for which no error has occurred;
	\item $P_1$= $|100 \rangle \langle 100|$ + $|011 \rangle \langle 011|$, which corresponds to the projector for which an error on the 1st qubit has occurred;
	\item $P_2$ = $|010 \rangle \langle 010|$ + $|101 \rangle \langle 101|$, which corresponds to the projector for which an error on the 2nd qubit has occurred;
	\item $P_3$ = $|001 \rangle \langle 001|$ + $|110 \rangle \langle 110|$, which corresponds to the projector for which an error on the 3rd qubit has occurred.
\end{enumerate}

In order to detect the syndrome we compute $\langle \psi| P_i | \psi \rangle $ in the decoded phase, which will be equal to 1 for the $i$-bit that has been flipped.
Measuring the syndrome does not affect the state in any way, neither before nor after the measurement. Furthermore, the syndrome gives no information on the state phase. We can recover the initial state with perfect accuracy by flipping again the qubit of interest. Though, we have already mentioned that this scheme works well only if errors occur on one or less of the three qubits.\newline
Similarly to the classical case, the minimum number of bit-flips needed to convert one valid quantum state into another represents the distance of the code. It quantifies the code's ability to correct errors, with higher distance indicating greater resilience.
We can now denote a given quantum code by means of the following three characterizing quantities: [n, k, d], where n represents the number of physical qubits, k denotes the number of logical qubits, and d stands for the code's distance. \newline

In this paragraph, we more formally define the Quantum Error Correctio (QEC) as we did in the classical case according to \cite{Cha06}. 
Let the quantum information to be a state $|\psi \rangle$ $\in$ $\mathscr{H}_A$. We can introduce ancillary qubits for redundancy. Ancillary qubits are replicas of the information that will be manipulated along with the data that we want to transmit.
Ancillary bits are part of an Hilbert space $\mathscr{H}_B$ and are initially in a state $|b \rangle$. When we encode information what we do is mapping the tensor product of $|\psi \rangle$ and $|b \rangle$ in a new Hilbert space $\mathscr{H}_C$ (the code space) through the application of an encoder operator $\textbf{E}$, which should be the equivalent of the generator matrix in classic models. In the same way we can define an Hilbert space  $\mathscr{H}_N$ to model the noise; this space more generally represents the noisy environment that introduces errors and is initially in a state $|n \rangle$. As given in \cite{Cha06}, the interaction between the information state and the environment is computed as the tensor product:

\begin{center}
	$|c' \rangle$ = $|c \rangle$ $\otimes$ $|n \rangle$ = $\sum_{i} (N_i c) \otimes |n_i \rangle $
\end{center}

with $N_i$ being a noise operator acting on $i$.
When we decode information through the decoding operator $\textbf{D}$ we want to map $|c' \rangle$ back to $|\psi \rangle$ $\otimes$ $|s_i \rangle$, which represent the original state $|\psi \rangle$ and its error syndrome $|s_i \rangle$. We can then use the error syndrome to correct $|\psi \rangle$ and get the initial state. However, in order to reproduce the classical case, the error syndrome should be in a bijective relationship with $N_i$ in order to recover the respective errors; furthermore, $|s_i \rangle$ should also be independent from $|\psi \rangle$ . Note that all $N_i$ can also be made linearly independent to avoid confounding errors. 
%Note also that $\sum_{i} N_i^{\dagger} N_i= I$ ensures that the $Tr[\sum_{i} N_i^{\dagger} \rho N_i]= 1$ with $\rho$ a general quantum state in  $\textbf{C}$. \newline

The above description of the quantum error behavior actually contains the conditions on error correctability to protect quantum information. 
This conditions are summed up into the equation given by the following theorem \cite{Nie06}: 

\begin{theorem}
	 Let $\mathscr{H}_C$ be a quantum code and $P$ the projector onto $C$. Suppose $N$ is a quantum operation with operation elements $\{N_i\}$. A necessary and sufficient condition for the existence of an error-correction operation $\mathcal{R}$ correcting $N$ on $C$ is that
	
	\begin{center}
		$PN_i^{\dagger}N_jP = \lambda_{ij}P$
	\end{center}
	
	for some self-adjoint matrix ($\lambda_{ij}$), $i,j\in\{1 \dots n\}$ with $\lambda_{ij} \in \mathbb{C}$ and for all $N_i$. 
\end{theorem}

The projector is a mathematical operation that projects any quantum state onto the code space. It ensures that any state acted upon by the error correction process is effectively confined to the subspace defined by the error-correcting code $C$ since, when quantum states undergo errors, these errors might cause the state to deviate from the code space. \newline
The condition essentially states that the error correction is successful if when applied to the states within $C$, the corrected state remains within the code space. \newline
We could generally say that it ensures that a noisy quantum state is not {\it too} noisy. More precisely, the projector $P$ forces the correction operation to act within the space where it provides reliable error-correction. In this sense, $P$ protects against excessive noise. The $Ns$ actually represent noise operators and if such an operation exists we say that $\{N_i\}$ forms a correctable set of errors. This would make the code correctable. \newline



\subsection{Fault-tolerant computation}

Quantum error-correction applications concerns not only the protection of transmitted quantum information from noise but also the protection of quantum information during computations. 
We start by briefly highlighting two main issues in quantum computation. The first issue is due to the fact that each component of a quantum circuit is subject to noise. 
What is done in general to make the computation fault-tolerant is to substitute qubits with encoded blocks of qubits by using a code protected from noise and substitute faulty gates with encoded gates also referred to as fault-tolerant procedures. 
The second issue concerns the fact that when we perform error-correction on encoded qubits we may introduce errors through the error-correction itself. \newline
%Addittionally, encoded gates aren't the only fault-tolerant procedures that we want to perform. In fact, we also want measurements of encoded qubits and state preparations to be fault-tolerant.\newline
%We know by theory that there exists a set of quantum gates through which each quantum computation can be expressed. Such set is comprised of the hadamard, phase, controlled-NOT and $\frac{\pi}{8}$ gates. 
%We also know that each of these gates can be realized falut-tolerantly. 
In the context of fault-tolerant quantum computation, it is possible to carry out a comprehensive range of logical operations on encoded quantum states. This is also done in a manner that results in the effective failure probability within the encoded states, scaling as a function of $p$, which is the error probability associated with the underlying gates. These errors could affect a single qubit but quantum error-correction codes are designed to correct them. However, in the process of error-correction itself, new errors can be introduced, and these are typically correlated with the original errors. The probability of introducing correlated errors during the error correction process is proportional to the square of the original error probability. This means that the effective failure probability scales quadratically with the probability of errors in the underlying gates. \newline

The above considerations lead us to the main result concerning fault tolerant compuatation: the threshold theorem \cite{Nie06}. Essentially, the theorem states that as long as the noise present in individual quantum gates remains below a specific constant threshold (the probability that each gates fails is $p<p_t$) it becomes feasible to reliably execute a quantum computation of arbitrary length. In fact, if we apply fault-tolerant computations on encoded states, achieving a quadratic reduction of the errors $O(p^2)$, the desired error thershold achieved can be made as low as desired with an increase in the circuit size by means of code concatenation. For further details see \cite{Nie06}.\newline
%We must specify that this theorem works under some reasonable assumptions reguarding the type of noise, meaning that indeed noise is not a real issue in quantum computation but we cannot correct errors from arbitrary noises.
%\begin{theorem}(Threshold theorem)
%A quantum circuit containing a quantity of gates determined by $p(n)$ can be effectively simulated with an error probability not exceeding $\epsilon$, employing a number of gates approximately proportional to $O(poly(\log p(n)/\epsilon)p(n))$. Each of these gates may experience failure with a probability no greater than $p$, given that $p$ remains below a specified constant threshold $p < p_{th}$. This simulation holds true under the condition of reasonable assumptions regarding the noise present in the underlying hardware.
%\end{theorem}



%--------------------------------------------











\newpage
\section{QEC in the Toric Code}
\label{sec:TC}

Broadly speaking, errors refer to the unintentional changes or flips in the physical signals that encode the information. These errors can be caused by various factors, such as external environmental noise. In the toric code, or in quantum systems in general, errors can be caused by what are often referred to as local perturbations. Local perturbations involve small disturbances that primarily affect individual qubits or a small region of the quantum system, causing the corruption of the stored quantum information. Single qubit errors can result in different types of errors such as bit-flips errors, phase-flips errors or a combination of them. Mathematically, local perturbations in the toric code framework can be described as operators that act on qubits of the system and can be represented using combinations of Pauli operators. For example, consider the following perturbation:

\begin{center}
	V = $\lambda \sum_{j} \sigma^x_j $
\end{center}

such that $\lambda \ll 1 $\cite{Kit02}. The ground states of the toric code Hamiltonian are protected from local perturbations of the form that we have described above but only if they are of moderate entity. In order to determine such entity we apply perturbation theory. Given an initial state $|k \rangle $ and a different orthogonal state $ |\psi \rangle $ both ground states of the toric code Hamiltonian, we have
%if we want to know how much these states overlap, after having applied the perturbation $V$ for $n$ times, we compute the following terms:

\begin{equation}
	 \langle \psi |V^n| k \rangle=0.                                    
\end{equation}

%Conversely, in (2.2) we consider an initial state $|k \rangle $ and an orthogonal state $ |\psi \rangle $, such that they belong, respectively, to a class $i$ and a class $j$ among the ones discussed in section 1.3:

%\begin{equation}
  %   \langle \psi|V^n| k \rangle=0  
%\end{equation}

%in order for {(2.1)} and {(2.2)} to be equal to zero, 
where we assumed that the order of the perturbation is less than $ \frac{N}{2}$, where $N$ is the length of the side of the lattice. 
If $n < \frac{N}{2}$, then the effect of the perturbation is of the order of $O(\lambda^{2n})$; for such order the toric code is not subject to local perturbations if their size is much smaller than the size of the torus.

%image
\begin{figure}
	\begin{center}
		
		\begin{tikzpicture}
			% Cerchio 1
			\draw (-3,0) circle (3cm);
			\filldraw (-3,0) circle (1pt) node[anchor=north] {$|\psi\rangle$};
			\filldraw (-3,0.3) circle (1pt) ;
			
			% Cerchio 2
			\draw (3,0) circle (3cm);
			\filldraw (3,0) circle (1pt) node[anchor=north] {$|k\rangle$};
			\filldraw (3,0.3) circle (1pt) ;
			
			\draw[] (-3,0) -- node[above] {${\bf N}$} (3,0);
			\draw[] (-3,0.3) -- node[above] {${\bf \frac{N}{2}}$} (0,0.3);
			\draw[] (3,0.3) -- node[above] {${\bf \frac{N}{2}}$} (0,0.3);
		\end{tikzpicture}
		
	\end{center}
	\caption{Consider the two big circles a visual representation of the state spaces of which $|\psi\rangle$ and $|k\rangle$ are part of. The distance between the eigenstates is N representing the length of a non-contactible loop that we need in order to be able to transition between the two states. In order to safeguard the integrity of the two states (no overlap of the circles) we have a margin equal to $\frac{N}{2}$ for each state, which corresponds to the entity of the perturbation that the system can bear. }
	\label{fig:QEC}
\end{figure}


To summarize, we can state that in order not to diverge from the state space of which state $| k \rangle$  is part of, the perturbation should be of the order of $n < \frac{N}{2}$. 
The interpretation in terms of quantum error correction is that the codewords are maximally distinguishable and therefore not corrupted by noise only for a perturbation of the order of $n < \frac{N}{2}$ (see figure 2.3). 
Indeed, when it comes to error correction we in principle convert an erroneous state into the one which is closer to it, i.e. into the one with minimum distance from it, because it takes less effort to do so. For instance, if a perturbation is of the order of $\frac{3N}{2}$ it would be more convienient to close the error string into a non-contractible loop rather than erasing it. \newline

%\newline
% There are 2L2 physical qubits in the code, N^2−1 plaquette and N^2−1 vertex
% operators. There are therefore 2N^2−2(2N^2) = 2 encoded qubits. 

Thus, for $n < \frac{N}{2}$ we can use the toric code to encode two qubits of information in a large number of physical qubits arranged on the squared lattice in such a way that the logical qubit can be protected from noise. The physical qubits are stored on the spins of the lattice but the logical qubits are encoded in the ground states of the Hamiltonian of the system. 
The method for encoding information in the toric code lies in the topological nature of the ground states. In fact, instead of directly manipulate individual qubits to store quantum information, we manipulate the entire lattice to encode and protect the logical qubit. The protection is due to the fact that errors generate the anyonic excitations presented in section 1.5. As already discussed, anyons follow specific rules, like braiding around each other, that allow us to protect the quantum information we want to store.\newline 

%We can do more than just store information. In fact, we can perform fault-tolerant computation using the same anyonic framework that we have described above. \newline
%In the context of the toric code, gates are relized through braiding of pairs of anyons. As shown in figure 2.3, we can follow the braiding of anyons in time and exchange them multiple times so that we are able to create different quantum operations. \newline
%We can have the usual $X$, $Z$ and Hadamard gates as shown below, by braiding pairs of anyons. It is important to mention that with braiding operations we cannot reach the entire bloch sphere of a qubit, so some quantum gates that are required for quantum universal computation will be missing from the set that we can create with braiding. Such missing operations can be supplemented through not topologically protected operations on the qubits, but which will of course have lower reliability. \newline

We can reframe all of the above physical information into the usual logical framework by relabelling the orthogonal ground states as logical sates: $|00\rangle$, $|01\rangle$, $|10\rangle$ and $|11\rangle$, in such a way that we are able to identify logical gates into those represented in figure 2.4 labelled as: $\overline{X}_1$,$\overline{X}_2$,$\overline{Z}_1$,$\overline{Z}_2$. \newline 
Such gates can be seen as string operators that create pairs of excitations that self-annihilate at the endpoints by winding all the way around the torus. 
These non-contractible loops play a crucial role in encoding quantum information in the toric code. In fact, the logical states of the two encoded qubits are determined by whether these loops are crossed an even or odd number of times. \newline
Overall we can determine the action of $\overline{X}_1$ as the logical gate maps $|00\rangle$ to $|10\rangle$, while $\overline{Z}_1$ as the logical gate that maps $|00\rangle$ to $|00\rangle$ and $|10\rangle$ to -$|10\rangle$. \newline
Similarly, the action of $\overline{X}_2$ logical gate maps $|00\rangle$ to $|01\rangle$, while $\overline{Z}_2$ maps $|11\rangle$ to $|11\rangle$ and $|01\rangle$ to -$|01\rangle$. For further details see \cite{Her20}.\newline

\begin{figure}
\begin{center}
	\begin{tikzpicture}
		% Draw dashed lines
		\foreach \i in {-3,-2.5,...,3}
		{
			\draw[dashed] (\i,-3) -- (\i,3);
		}
		\foreach \j in {-3,-2.5,...,3}
		{
			\draw[dashed] (-3,\j) -- (3,\j);
		}
		
		
		
		% Draw solid grid and nodes with circles in the middle of each side
		\draw[step=1cm] (-3,-3) grid (3,3);
		\foreach \i in {-2.5,...,2.5}
		{
			\foreach \j in {-2.5,...,2.5}
			{
				
				
				\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
					\node[right,xshift=0.2cm,yshift=0.4cm] {};
					% Convert \j and \i to integers
					\pgfmathtruncatemacro{\intj}{\j}
					\pgfmathtruncatemacro{\inti}{\i}
					
					% Draw circles at the midpoints of each side
					\ifnum\intj=2
					\draw node[draw,circle,fill=gray] at (0,0.5) {};
					\else
					\draw node[draw,circle,fill=white] at (0,0.5) {};
					\fi
					
					\ifnum\inti=2
					\draw node[draw,circle,fill=gray] at (0.5,0) {};
					\else
					\draw node[draw,circle,fill=white] at (0.5,0) {};
					\fi
					
					\draw node[draw,circle,fill=white] at (0,-0.5) {};
					\draw node[draw,circle,fill=white] at (-0.5,0) {};
				\end{scope}
			}
		}
		
		\foreach \i in {-1.5,...,-1.5} %column
		{
			
			\draw[blue!50, line width=1.5mm] (\i,-3) -- (\i,3);
			%\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,3) {};
			\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,2) {};
			\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,1) {};
			\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,0) {};
			\node[draw, circle, fill=purple!50,label=center:\textbf{$\pm$}] at (\i,-1) {};
			\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,-2) {};
			\node[draw, circle, fill=blue!50,label=center:\textbf{Z}] at (\i,-3) {};
			
			\node[label={[anchor=south, inner sep=2pt]left:\textbf{$\overline{Z}_1$}}] at (\i,-3.5) {};
		}
		\foreach \j in {1.5,...,1.5}
		{
			
			\draw[blue!50, line width=1.5mm] (-3, \j) -- (3, \j);
			\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z}] at (2,\j) {};
			\draw node[draw,circle,fill=purple!50,label=center:\textbf{$\pm$}] at (1,\j) {};
			\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z}] at (0,\j) {};
			\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z}] at (-1,\j) {};
			\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z}] at (-2,\j) {};
			\draw node[draw,circle,fill=blue!50,label=center:\textbf{Z}] at (-3,\j) {};
			
			\node[label={[anchor=south, inner sep=2pt]left:\textbf{$\overline{Z}_2$}}] at (-3.5,\j) {};
			
		}
		
		
		
		\foreach \j in {-1,...,-1}
		{
			
			\draw[red!80, line width=1.5mm] (-3, \j) -- (3, \j);
			\draw node[draw,circle,fill=red!80,label=center:\textbf{X}] at (2.5,\j) {};
			\draw node[draw,circle,fill=red!80,label=center:\textbf{X}] at (1.5,\j) {};
			\draw node[draw,circle,fill=red!80,label=center:\textbf{X}] at (0.5,\j) {};
			\draw node[draw,circle,fill=red!80,label=center:\textbf{X}] at (-0.5,\j) {};
			\draw node[draw,circle,fill=purple!80,label=center:\textbf{$\pm$}] at (-1.5,\j) {};
			\draw node[draw,circle,fill=red!80,label=center:\textbf{X}] at (-2.5,\j) {};
			
			\node[label={[anchor=south, inner sep=2pt]left:\textbf{$\overline{X}_1$}}] at (-3.5,\j) {};
			
			
		}
		\foreach \i in {1,...,1}
		{
			
			\draw[red!80, line width=1.5mm] (\i,-3) -- (\i,3);
			\node[draw, circle, fill=red!80,label=center:\textbf{X}] at (\i,2.5) {};
			\node[draw, circle, fill=purple!80,label=center:\textbf{$\pm$}] at (\i,1.5) {};
			\node[draw, circle, fill=red!80,label=center:\textbf{X}] at (\i,0.5) {};
			\node[draw, circle, fill=red!80,label=center:\textbf{X}] at (\i,-0.5) {};
			\node[draw, circle, fill=red!80,label=center:\textbf{X}] at (\i,-1.5) {};
			\node[draw, circle, fill=red!80,label=center:\textbf{X}] at (\i,-2.5) {};
			
			\node[label={[anchor=south, inner sep=2pt]left:\textbf{$\overline{X}_2$}}] at (\i,-3.5) {};
			
			%
			
		}
		
		
	\end{tikzpicture}
\end{center}
\caption{Logical gates on the toric code.}
\label{fig:gates}
\end{figure}

Errors that occur in the system can disrupt these non-contractible loops. However, the topological nature of the toric code ensures that errors affecting the logical qubits can be detected and corrected by measuring the syndrome associated with these non-contractible loops. By performing appropriate error correction procedures based on the outcomes of these measurements, the encoded quantum information can be protected against errors. 



\subsection{Error detection and correction}

We know that the Hilbert space of the ground states of the toric code is composed by the states $|\psi\rangle $ satisfying the following constraints: 

\begin{center}
	$A_{\vec{v}}|\psi\rangle $ = $|\psi\rangle $ 
\end{center}
\begin{center}
	$B_{\vec{p}}|\psi\rangle $ = $|\psi\rangle $.
\end{center}

When errors occur on a given ground state $|\psi\rangle$, the resulting state does not belong anymore to the ground state manifold. This is because, due to errors, there would be some vertex or plauqette operators that yield eigenvalue equal to -1. \newline
By combining simultaneous measurements of vertex and plaquette operators with the anyonic nature of the excitations, we can find methods to identify and correct errors whenever it is possible. In the following paragraphs, we briefly discuss how errors can be described as anyon pairs and consequently we will identify several error scenarios and study the relative error syndromes and corrective actions that can be applied. \newline

%1. Errors Adjacent to Vertices:
Due to the commutation properties of string operators that we have discussed in the previous sections, we can say that vertex operators are designed to detect an odd number of bit-flips errors that occur in the neighbourhood of the vertex on which they are applied. When an error affects a qubit adjacent to such vertex, it can disrupt the commuting relationship between the Pauli operators making up the vertex operator. As a result, the measurement outcome of the vertex operator may deviate from its expected +1 eigenvalue, i.e.

\begin{center}
	$A_{\vec{v}}|\phi\rangle $ = -$|\phi\rangle $.
\end{center}

This deviation indicates that an error has occurred adjacently to the vertex $\vec{v}$. However, the measurement of the a single vertex operator is not sufficient to detect the exact position of the error. Moreover, an $\epsilon$-excitation is created in the vertex $\vec{v}$. Since excitations are always created in pairs, we can assume another excitation of the same kind is present at the other endpoint of the error string. \newline
%2. Errors in Plaquette Regions:
In view of the duality between vertex and plaquette operators, plaquette operators are designed to detect an odd number of phase-shift errors that occur within plaquette regions. When an error affects a qubit within such region, it alters the state of those qubits. As a result, the product of Pauli operators making up the plaquette operator may no longer commute with the qubit affected by the error. Consequently, the measurement outcome of the plaquette operator will not output its expected eigenvalue. This deviation indicates that an error has occurred within the plaquette region. This error is associated with the creation of an $\mu$-excitation in the application site $\vec{p}$ of the plaquette operator. \newline

More in general, errors on the toric code can be more complex than the simple creation of anyon pairs; though, as mentioned in \cite{Kas19,Bro14}, in order to be able to correct them we only need to know how to correct errors generated through $\sigma^x$ and $\sigma^z$ operators. Anyon pairs are connected through paths that we have named {\it error strings}. We are now going to discuss the three main error scenarios that can arise: in the first case, isolated error strings are created, resulting in anyon pairs on the lattice; in the second case, anyons pairs may self-annihilate by forming contractible closed loops, resulting in no error; in the third case, we can get a non-contactible loop and thus creates a logical operation on the quantum state. \newline
In order to better clarify the above concepts, we take as example a bit-flip error that could occur on the lattice and always assume an odd number of errors involved in each vertex operator. There are three possible ways an error could occur, as depicted in figure 2.6: 

\begin{enumerate}
	\item Isolated error link: isolated bit-flip that can be detected through the measurement of the adjacent vertices;
	
	\item Adjacent error links: they are composed of multiple adjacent single erroneous edges. Similary to the case above, we are only able to identify the two endpoints through simultaneous measurements (see figure 2.7);
	
	\item Undetectable errors: these types of errors are not visible because their two endpoints overlap: they indeed have no endpoints. We can divide this latter category of errors in two : the contractible loops, which do not alter the state, and the non-contractible loops, which cause irreversible errors.
	
\end{enumerate}


\begin{figure}
	
	\begin{center}
		\begin{tikzpicture}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\fi
						
						\ifnum\intj=1
						\ifnum\inti=0
						\draw node[label=north:\textbf{-1}] at (-0.5,-0.5) {};
						\else
						\draw node[label=left:\textbf{+1}] at (0,-0.5) {};
						\fi
						\else
						\draw node[label=left:\textbf{+1}] at (0,-0.5) {};
						\fi
						
					\end{scope}
				}
			}
			
			
			\foreach \j in {1,...,1}
			{
				
				\draw[dashed, red!50, line width=1.5mm] (-1, \j) -- (-0, \j);
				
			}
			
			
			
			
		\end{tikzpicture}
	\end{center}
	
	\vspace*{1cm}
	
	\begin{center}
		\begin{tikzpicture}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\fi
						
						
						
						\ifnum\intj=1
						\ifnum \inti=0
						\draw node[label=center:\textbf{}] at (-0.5,0) {};
						\draw node[label=center:\textbf{}] at (0.5,0) {};
						\else
						\ifnum \inti>1
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						\ifnum \inti<1
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						\fi
						\else
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						
					\end{scope}
				}
			}
			
			
			\foreach \j in {1,...,1}
			{
				%\draw[black!50, line width=1.5mm] (-2, \j) -- (-1.5, \j);
				\draw[dashed,red!50, line width=1.5mm] (-1, \j) -- (0, \j);
				\draw node[label=north:\textbf{-1}] at (-1,\j) {};
				\draw[dashed, red!50, line width=1.5mm] (0, \j) -- (1, \j);
				\draw node[label=north:\textbf{-1}] at (1,\j) {};
				
			}
			
			
			
			
		\end{tikzpicture}
	\end{center}
	
	\vspace*{1cm}
	
	\begin{center}
		\begin{tikzpicture}
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						% Draw circles at the midpoints of each side
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\fi
						
						\draw node[label=left:\textbf{+1}] at (0,-0.5) {};
						
					\end{scope}
				}
			}
			
			\foreach \i in {-2,...,-2}
			{
				\draw[dashed,red!50, line width=1.5mm] (\i,-1) -- (\i,1.5);
				
				
				\draw[dashed,red!50, line width=1.5mm] (\i,1) -- (\i,2);
				
				
				
			}
			
			\foreach \j in {2,...,2}
			{
				
				\draw[dashed,red!50, line width=1.5mm] (-2, \j) -- (-1.5, \j);
				
				
				\draw[dashed,red!50, line width=1.5mm] (-1.5, \j) -- (1, \j);
				
				
			}
			
			
			\foreach \i in {1,...,1}
			{
				\draw[dashed,red!50, line width=1.5mm] (\i,-1) -- (\i,2);
				
				
			}
			
			\foreach \j in {-1,...,-1}
			{
				\draw[dashed, red!50, line width=1.5mm] (-2, \j) -- (1, \j);
				
				
			}
			
			
			\foreach \i in {2,...,2}
			{
				\draw[dashed,red!50, line width=1.5mm] (\i,-3) -- (\i,3);
				
				
			}
			
			
		\end{tikzpicture}
	\end{center}
	
	\caption{Bit-flip error scenarios on the toric code. Error strings made up by $\sigma^x$ Pauli operators (local bit-flips) are represented in red. To each vertex is assigned a +1 eigenvalue of the associated vertex operator. Whenever an odd numer of erroneous qubits is involved in a vertex operator we assign a -1 to that vertex (see figure 2.7). }
	\label{fig:errors}
\end{figure}


Such errors can be detected through  simultaneous measurement of vertex (and plaquette) operators of the Hamiltonian (figure 2.7). The fact that the vertex and plaquette operators commute with each other (Proposition 1.4) along with the fact that the states in the ground state manifold are eigenfunctions of the vertex and plaquette operators (Proposition 1.6) and the fact that string operators commute and anticommute with $A_{\vec{v}}$ and $B_{\vec{p}}$ operators (Proposition 1.10, which states that the anyonic excitations are eigenfunctions of vertex and plaquette operators with eigwnvalues +1 or -1) allows us to measure the operators without destrying the initial given state. In practice, it is is posssible to measure, on the same physical state, all the $A_{\vec{v}}$ and $B_{\vec{p}}$ operators withouth modifying the underlying state. The resulting measurements are called {\it error syndrome}, which gives information about the error strings \cite{Den02}. As a consequence what we do is using algorithms that estimate the way errors formed by connecting pairs of endpoints by selecting the shortest string that connects two -1 eigenvalues yielded by the vertex operators, i.e. we make use of the minium distance between two -1 eigenvalues. \newline

\begin{figure}
	\begin{center}
		\begin{tikzpicture}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\fi
						
						
						
						\ifnum\intj=1
						\ifnum \inti=0
						\draw node[label=center:\textbf{}] at (-0.5,0) {};
						\draw node[label=center:\textbf{}] at (0.5,0) {};
						\else
						\ifnum \inti>1
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						\ifnum \inti<1
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						\fi
						\else
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						
					\end{scope}
				}
			}
			
			
			\foreach \j in {1,...,1}
			{
				%\draw[black!50, line width=1.5mm] (-2, \j) -- (-1.5, \j);
				\draw[dashed,red!50, line width=1.5mm] (-1, \j) -- (0, \j);
				\draw node[label=north:\textbf{}] at (-1,\j) {};
				\draw[dashed, red!50, line width=1.5mm] (0, \j) -- (1, \j);
				\draw node[label=north:\textbf{}] at (1,\j) {};
				
			}
			
			\foreach \j in {1,...,1}
			{
				\draw[blue!80, line width=1.5mm] (0.5, \j) -- (1.5, \j);
				\draw[blue!80, line width=1.5mm] (-1.5, \j) -- (-0.5, \j);
				\node[draw, circle, fill=blue!80,label=center:\textbf{Z}] at (1.5,\j) {};
				\node[draw, circle, fill=blue!80,label=center:\textbf{Z}] at (0.5,\j) {};
				\node[draw, circle, fill=blue!80,label=center:\textbf{Z}] at (-0.5,\j) {};
				\node[draw, circle, fill=blue!80,label=center:\textbf{Z}] at (-1.5,\j) {};
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[blue!80, line width=1.5mm] (\i, 0.5) -- (\i, 1.5);
				\node[draw, circle, fill=blue!80,label=center:\textbf{Z}] at (\i,0.5) {};
				\node[draw, circle, fill=blue!80,label=center:\textbf{Z}] at (\i,1.5) {};
				
				
				
			}
			
			\foreach \i in {1,...,1}
			{
				\draw[blue!80, line width=1.5mm] (\i, 0.5) -- (\i, 1.5);
				\node[draw, circle, fill=blue!80,label=center:\textbf{Z}] at (\i,0.5) {};
				\node[draw, circle, fill=blue!80,label=center:\textbf{Z}] at (\i,1.5) {};
				
			}
		
	
			% Posiziona la label "-1" nel punto (i,j)
			\node at (1,1) {\bf \large -1};
			\node at (-1,1) {\bf \large -1};
			
			
		\end{tikzpicture}
	\end{center}
	\caption{Example of error syndrome yielded by the simultaneous measurement of vertex operators after an error string as occurred (red). For the sake of clarity, the dual lattice and the spins over the edges are omitted, as they are not involved in the current matter. The boundary conditions are highlighted in gray. We represent the vertex operators involved in the error string along with their respective -1 eigenvalue, resulting from the anticommutation of $\sigma^z\sigma^x$ for an odd number of erroneous edges.}
	\label{fig:simmes}
\end{figure}



Given a bit-flip error as above, starting from a state $|00\rangle$ where we have no loop, we also determine three different error scenarions for error-correction, as depicted in figure 2.8: 

\begin{enumerate}
	\item First scenario: the algorithm correctly identifies an error string and erases it by applying the inverse of the Pauli operator that caused it;
	
	\item Second scenario: the algorithm connects two endpoints of an error string. Since there are several paths of the same length that can connect two endpoints, it might happen that we fail to correctly select all the edges involved and end up flipping previously correct ones. This would mean propagating the error on the lattice. \newline 
	Moreover, we can also end up into two situations: we could obtain contractible loops or we could end up having a non-contractible loop, which irremediably damages quantum information since we would not be able to detect the two endpoints anymore due to their overlap.
	
	\item Third scenario: we connect separate open error strings into a single one. Then, the feasibility of erasing the error can be divided in the two cases discussed in the scenario above: we form a contractible closed loop or we end up with a non-contractible loop. 
	
\end{enumerate}


Overall, the error-correction can be said to be effective whenever we end up in scenario 1 or in scenario 2 and 3 but only by forming contractible loops that leave the state unaltered. \newline

As a consequence, the goal is to decrease the probability of uncorrectable errors. There exist two known methods to achieve this goal. The first method involves increasing the size of the torus; by doing so, we increase the number of erroneous edges needed to form a non-contractible loop. Notice that this would mean to increase the Hamming distance of the code.\newline 
The second method involves reducing the probability $p$ with which each edge is flipped. In this way the errors would tend not to propagate far away from where they originated and could thus be detected and corrected in an easier way. When $p$ increases, ambiguity arises due to the fact that it would become more and more challenging to correclty identify paths connecting anyon pairs with acceptable accuracy; thus, error-correction may not succeed \cite{Zbi19}. \newline
% The reduction of $p$ can be realized by measuring subsequent error syndromes more often, thus incraesing the frequency with which we produce syndrome measurements.
\newline


\begin{figure}
	\begin{center}
		\begin{tikzpicture}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\fi
						
						\ifnum\intj=1
						\ifnum\inti=0
						\draw node[label=north:\textbf{+1}] at (-0.5,-0.5) {};
						\else
						\draw node[label=left:\textbf{+1}] at (0,-0.5) {};
						\fi
						\else
						\draw node[label=left:\textbf{+1}] at (0,-0.5) {};
						\fi
						
					\end{scope}
				}
			}
			
			
			\foreach \j in {1,...,1}
			{
				
				\draw[dashed, red!50, line width=1.5mm] (-1, \j) -- (-0, \j);
				
				
			}
			
			\foreach \j in {0.8,...,0.8}
			{
				
				\draw[black, line width=1.5mm] (-1, \j) -- (-0, \j);
				
			}
			
			
			
			
		\end{tikzpicture}
	\end{center}
	
	\vspace*{1cm}
	
	\begin{center}
		\begin{tikzpicture}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\fi
						
						
						
						\ifnum\intj=1
						\ifnum \inti=0
						\draw node[label=center:\textbf{}] at (-0.5,0) {};
						\draw node[label=center:\textbf{}] at (0.5,0) {};
						\else
						\ifnum \inti>1
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						\ifnum \inti<1
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						\fi
						\else
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						
					\end{scope}
				}
			}
			
			
			\foreach \j in {1,...,1}
			{
				%\draw[black!50, line width=1.5mm] (-2, \j) -- (-1.5, \j);
				\draw[dashed,red!50, line width=1.5mm] (-1, \j) -- (0, \j);
				\draw node[label=north:\textbf{+1}] at (-1,\j) {};
				\draw[dashed, red!50, line width=1.5mm] (0, \j) -- (1, \j);
				\draw node[label=north:\textbf{+1}] at (1,\j) {};
				
			}
			
			\foreach \j in {0.8,...,0.8}
			{
				
				\draw[black, line width=1.5mm] (0, \j) -- (1, \j);
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (\i,0) -- (\i, 1 );
				
			}
			
			\foreach \i in {0,...,0}
			{
				
				\draw[black, line width=1.5mm] (\i,0) -- (\i, 0.8 );
				
			}
			
			\foreach \j in {0,...,0}
			{
				
				\draw[black, line width=1.5mm] (-1,\j) -- (0,\j);
				
			}
			
			\foreach \j in {-2,...,-2}
			{
				
				\draw[dashed,red!50, line width=1.5mm] (-3,\j) -- (-1,\j);
				
			}
			\foreach \i in {-1,...,-1}
			{
				
				\draw[dashed,red!50, line width=1.5mm] (\i,-2) -- (\i, -1 );
				
			}
			\foreach \j in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (-1,\j) -- (0,\j);
				
			}
			
			\foreach \j in {-2,...,-2}
			{
				
				\draw[dashed,red!50, line width=1.5mm] (1,\j) -- (3,\j);
				
			}
			\foreach \i in {1,...,1}
			{
				
				\draw[black, line width=1.5mm] (\i,-2) -- (\i, -1 );
				
			}
			\foreach \j in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (0, \j) -- (1, \j);
				
			}
			
			
			
		\end{tikzpicture}
	\end{center}
	
	\vspace*{1cm}
	
	\begin{center}
		\begin{tikzpicture}
			
			
			
			% Draw solid grid and nodes with circles in the middle of each side
			\draw[step=1cm] (-3,-3) grid (3,3);
			\foreach \i in {-2.5,...,2.5}
			{
				\foreach \j in {-2.5,...,2.5}
				{
					
					
					\begin{scope}[transform canvas={xshift=\i cm,yshift=\j cm}]
						
						\node[right,xshift=0.2cm,yshift=0.4cm] {};
						% Convert \j and \i to integers
						\pgfmathtruncatemacro{\intj}{\j}
						\pgfmathtruncatemacro{\inti}{\i}
						
						\ifnum\intj=2
						\draw node[draw,circle,fill=gray] at (0,0.5) {};
						\fi
						
						\ifnum\inti=2
						\draw node[draw,circle,fill=gray] at (0.5,0) {};
						\fi
						
						
						
						\ifnum\intj=1
						\ifnum \inti=1
						\draw node[label=center:\textbf{}] at (-0.5,0) {};
						\draw node[label=center:\textbf{}] at (0.5,0) {};
						\else
						\ifnum \inti>1
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						\ifnum \inti<1
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						\fi
						\else
						\draw node[label=center:\textbf{+1}] at (-0.5,-0.5) {};
						\fi
						
					\end{scope}
				}
			}
			
			
			
			\foreach \j in {2,...,2}
			{
				%\draw[black!50, line width=1.5mm] (-2, \j) -- (-1.5, \j);
				\draw[black, line width=1.5mm] (-1, \j) -- (0, \j);
				\draw[dashed, red!50, line width=1.5mm] (0, \j) -- (1, \j);
				
				
			}
			
			\foreach \j in {1.2,...,1.2}
			{
				
				\draw[black, line width=1.5mm] (0, \j) -- (2, \j);
				
			}
			\foreach \j in {1,...,1}
			{
				
				\draw[dashed, red!50, line width=1.5mm] (1, \j) -- (2, \j);
				
			}
			
			\foreach \i in {-1,...,-1}
			{
				
				\draw[dashed, red!50, line width=1.5mm] (\i,0) -- (\i, 1 );
				
			}
			\foreach \i in {1,...,1}
			{
				
				\draw[dashed, red!50, line width=1.5mm] (\i,1) -- (\i, 2 );
				
			}
			\foreach \i in {-1,...,-1}
			{
				
				\draw[dashed, red!50, line width=1.5mm] (\i,1) -- (\i, 2 );
				
			}
			
			\foreach \i in {0,...,0}
			{
				
				\draw[black, line width=1.5mm] (\i,0) -- (\i, 1.2 );
				
			}
			\foreach \j in {0,...,0}
			{
				
				\draw[dashed, red!50, line width=1.5mm] (-1,\j) -- (0,\j);
				
			}
			
			\foreach \j in {-2,...,-2}
			{
				
				\draw[dashed, red!50, line width=1.5mm] (-3,\j) -- (-2,\j);
				
			}
			\foreach \j in {-2,...,-2}
			{
				
				\draw[black, line width=1.5mm] (-2,\j) -- (-1,\j);
				
			}
			\foreach \i in {-1,...,-1}
			{
				
				\draw[dashed, red!50, line width=1.5mm] (\i,-2) -- (\i, -1 );
				
			}
			\foreach \j in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (-1,\j) -- (0,\j);
				
			}
			
			\foreach \j in {-2,...,-2}
			{
				
				\draw[dashed, red!50, line width=1.5mm] (1,\j) -- (3,\j);
				
			}
			
			\foreach \i in {1,...,1}
			{
				
				\draw[black, line width=1.5mm] (\i,-2) -- (\i, -1 );
				
			}
			\foreach \j in {-1,...,-1}
			{
				
				\draw[black, line width=1.5mm] (0, \j) -- (1, \j);
				
			}
			\foreach \j in {-2.2,...,-2.2}
			{
				
				\draw[black, line width=1.5mm] (1, \j) -- (1, \j);
				
			}
			
			
			
		\end{tikzpicture}
	\end{center}
	
	\caption{Bit-flip error correction scenarios on the toric code. The correction is shown through black strings connecting anyon pairs in several ways. The correction still consists of Pauli operators of the same type of the error string, i.e. $\sigma^x$, which represent the inverse of the bit-flip errors.}
	\label{fig:errorscorr}
\end{figure}


To summarize, the process of identifying and correcting errors relies on the relationship between the observed syndrome and the underlying errors that occurred during quantum computation. 
The syndrome, obtained through simultaneous measurements of vertex and plaquette operators, provides crucial information about the presence and location of errors within the quantum code. However, due to the complexity of quantum systems and the nature of errors, the mapping between the observed syndrome and the actual error is not always one-to-one. 
This lack of a bijective correspondence between syndromes and errors arises because multiple distinct errors can lead to identical syndromes. In other words, these errors are indistinguishable based solely on their syndromes. 
This ambiguity in error identification represents a significant challenge to error-correction techniques, as it complicates the task of precisely correcting the errors that occurred during the computation. Effectively addressing this challenge requires the development of sophisticated error correction procedures that can effectively handle the degeneracy related to the mapping between syndromes and error. These procedures may involve advanced decoding algorithms and error mitigation techniques. \newline

In conclusion, the understanding of the non-trivial relationship between syndromes and errors highlights the importance of robust error-correction strategies in quantum computing. Addressing this challenge is essential for maintaining the integrity of encoded quantum information and to realize the potential of fault-tolerant quantum computation in the future. \newline

















%---------------------------------------------------------------








%-------------------------------------------------------------------------
%	BIBLIOGRAPHY
%-------------------------------------------------------------------------

\addtocontents{toc}{\vspace{2em}} % Add a gap in the Contents, for aesthetics
%\bibliography{Thesis_bibliography} % The references information are stored in the file named "Thesis_bibliography.bib"
\begin{thebibliography}{99} % Replace '99' with the widest label in your bibliography
	\bibitem[Bro14]{Bro14} D. Browne, {\it Topological Codes and Computation}, Lecture notes, unpublished, 2014.
	\bibitem[Cor23]{Cor23} M. Correggi, \textit{Aspetti Matematici della Meccanica Quantistica}, Lecture notes, unpublished, 2023.
	\bibitem[Cha06]{Cha06} Hsun-Hsien Chang, "An Introduction to Error-Correcting Codes: From Classical to Quantum", {\it arXiv: quant-ph/0602157}, 2006.
	\bibitem[Den02]{Den02} E. Dennis, A. Kitaev, A. Landhal, J. Preskill, "Topological Quantum Memory", {\it Journal of Mathematical Physics }, 2002.
	\bibitem[Her20]{Her20} P. Herringer, "The Toric Code", {\it Rutgers Physics}, 2020.
	\bibitem[Kas19]{Kas19} M. Kastroyano, {\it Quantum Error Correction}, Lecture notes, unpublished, 2018-19.
	\bibitem[Kha98]{Kha98} A. Khare, {\it Fractional statistics and quantum theory}, World Scientific, 1998.
	\bibitem[Kit02]{Kit02} A. Yu. Kitaev, "Fault-tolearnt quantum computation by anyons", {\it Annals of Physics}, 2-30, 2002.
	\bibitem[Nie06]{Nie06} M. A. Nielsen, I. L. Chuang, {\it Quantum Computation and Quantum Information}, Cambridge University Press, 2010.
	\bibitem[Odd20]{Odd20} L. Oddis, {\it PhD Thesis: Two-Anyon Schrödinger Operators}, 2019-2020.
	\bibitem[Pre04]{Pre04} J. Preskill, {\it Lecture Notes for Physics 219:
		Quantum Computation}, Lecture notes, unpublished, 2019.
	\bibitem[Rao01]{Rao01} S. Rao, "An Anyon Primer", {\it Models and Techniques of Statistical Physics}, 2001.
	\bibitem[Rao16]{Rao16} S. Rao, "Introduction to abelian and non-abelian anyons", {\it Harish-Chandra Research Institute}, 1-20, {2016}.
	\bibitem[Wil91]{Wil91} F. Wilczek, "Anyons", {\it Scientific American}, 58-65, 1991.
	\bibitem[Zbi19]{Zbi19} M. Zbinden, {\it PhD Thesis: Quantum Error Correction for the Toric Code}, 2019.

\end{thebibliography}


%-------------------------------------------------------------------------
%	APPENDICES
%-------------------------------------------------------------------------

\cleardoublepage
\addtocontents{toc}{\vspace{2em}} % Add a gap in the Contents, for aesthetics


% LIST OF FIGURES
\listoffigures



% ACKNOWLEDGEMENTS
\chapter*{Acknowledgements}
Here you might want to acknowledge someone.

\cleardoublepage

\end{document}
